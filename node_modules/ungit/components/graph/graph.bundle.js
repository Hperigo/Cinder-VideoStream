(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){


var ko = require('knockout');
var Vector2 = require('ungit-vector2');
var GitNodeViewModel = require('./git-node').GitNodeViewModel;
var RefViewModel = require('./ref.js').RefViewModel;
var components = require('ungit-components');
var moment = require('moment');
var _ = require('lodash');
var GraphViewModel = require('./graph-graphics/graph').GraphViewModel;
var EdgeViewModel = require('./graph-graphics/edge').EdgeViewModel;

components.register('graph', function(args) {
  return new GitGraphViewModel(args.server, args.repoPath);
});

var GitGraphViewModel = function(server, repoPath) {
  var self = this;
  this.server = server;
  this.repoPath = repoPath;
  this.currentRemote = ko.observable();
  this.maxNNodes = 25;
  this.nodes = ko.observable([]);
  this.edgesById = {};
  this.refs = ko.observableArray();
  this.nodesById = {};
  this.refsByRefName = {};
  this.nodesLoader = components.create('progressBar', {
      predictionMemoryKey: 'gitgraph-' + self.repoPath,
      fallbackPredictedTimeMs: 1000,
      temporary: true
    });
  this.checkedOutBranch = ko.observable();
  this.checkedOutRef = ko.computed(function() {
    if (self.checkedOutBranch())
      return self.getRef('refs/heads/' + self.checkedOutBranch());
    else
      return null;
  });
  this.HEAD = ko.observable();
  this.hoverGraphAction = ko.observable();
  this.currentActionContext = ko.observable();
  this.scrolledToEnd = _.debounce(function() {
    self.maxNNodes = self.maxNNodes + 25;
    self.loadNodesFromApi();
  }, 1000, true);
  this.graphic = new GraphViewModel();
  this.graphic.offset(new Vector2(5, 200));
  this.HEAD.subscribe(function(value) {
    self.graphic.commitNodeEdge.nodeb(value);
    self.graphic.showCommitNode(!!value);
    if (value)
      self.graphic.commitNode.color(value.color());
  });

  this.nodes.subscribe(function(nodes) {
    var edges = [];
    nodes.forEach(function(node) {
      node.parents().forEach(function(parentSha1) {
        edges.push(self.getEdge(node.sha1, parentSha1));
      });
    });
    self.graphic.nodes(nodes);
    self.graphic.edges(edges);
  });

  this.hoverGraphAction.subscribe(function(value) {
    if (value) {
      if (value.createHoverGraphic)
        self.graphic.hoverGraphActionGraphic(value.createHoverGraphic());
    } else {
      self.graphic.hoverGraphActionGraphic(null);
    }
  });

  this.loadNodesFromApiThrottled = _.throttle(this.loadNodesFromApi.bind(this), 500);
  this.updateBranchesThrottled = _.throttle(this.updateBranches.bind(this), 500);
  this.loadNodesFromApiThrottled();
  this.updateBranchesThrottled();
}
GitGraphViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('graph', this, {}, parentElement);
}
exports.GitGraphViewModel = GitGraphViewModel;
GitGraphViewModel.prototype.updateAnimationFrame = function(deltaT) {
  this.graphic.updateAnimationFrame(deltaT);
}
GitGraphViewModel.prototype.onProgramEvent = function(event) {
  if (event.event == 'git-directory-changed') {
    this.loadNodesFromApiThrottled();
    this.updateBranchesThrottled();
  } else if (event.event == 'request-app-content-refresh') {
    this.loadNodesFromApiThrottled();
  } else if (event.event == 'remote-tags-update') {
    this.setRemoteTags(event.tags);
  } else if (event.event == 'current-remote-changed') {
    this.currentRemote(event.newRemote);
  }
}
GitGraphViewModel.prototype.loadNodesFromApi = function(callback) {
  var self = this;
  this.nodesLoader.start();
  this.server.get('/log', { path: this.repoPath, limit: this.maxNNodes }, function(err, logEntries) {
    if (err) {
      self.nodesLoader.stop();
      if (callback) callback();
      return err.errorCode == 'no-such-path';
    }
    self.setNodesFromLog(logEntries);
    self.nodesLoader.stop();
    if (callback) callback();
  });
}
GitGraphViewModel.prototype.updateBranches = function() {
  var self = this;
  this.server.get('/checkout', { path: this.repoPath }, function(err, branch) {
    if (err && err.errorCode == 'not-a-repository') return true;
    if (err) return;
    self.checkedOutBranch(branch);
  });
}

GitGraphViewModel.prototype.setRemoteTags = function(remoteTags) {
  var self = this;
  var nodeIdsToRemoteTags = {};
  remoteTags.forEach(function(ref) {
    if (ref.name.indexOf('^{}') != -1) {
      var tagRef = ref.name.slice(0, ref.name.length - '^{}'.length);
      var name = 'remote-tag: ' + ref.remote + '/' + tagRef.split('/')[2];
      var refViewModel = self.getRef(name);
      var node = self.getNode(ref.sha1);
      refViewModel.node(node);

      nodeIdsToRemoteTags[ref.sha1] = nodeIdsToRemoteTags[ref.sha1] || [];
      nodeIdsToRemoteTags[ref.sha1].push(refViewModel);
    }
  });

  for(var key in this.nodesById)
    this.nodesById[key].remoteTags(nodeIdsToRemoteTags[key] || []);
}

GitGraphViewModel.prototype.setNodesFromLog = function(nodesData) {
  var self = this;
  var nodeVMs = [];
  nodesData.forEach(function(nodeData) {
    var nodeViewModel = self.getNode(nodeData.sha1);
    // Only set the data for the node once (since nodes never change)
    if (!nodeViewModel.isInited) nodeViewModel.setData(nodeData);
    nodeVMs.push(nodeViewModel);
    if (nodeData.refs) {
      var refVMs = nodeData.refs.map(function(ref) {
        var refViewModel = self.getRef(ref);
        refViewModel.node(nodeViewModel);
        return refViewModel;
      });
      nodeViewModel.branchesAndLocalTags(refVMs);
    }
  });
  this.setNodes(nodeVMs);
}
GitGraphViewModel.prototype.getNode = function(sha1) {
  var nodeViewModel = this.nodesById[sha1];
  if (!nodeViewModel) nodeViewModel = this.nodesById[sha1] = new GitNodeViewModel(this, sha1);
  return nodeViewModel;
}
GitGraphViewModel.prototype.getRef = function(fullRefName, constructIfUnavailable) {
  if (constructIfUnavailable === undefined) constructIfUnavailable = true;
  var refViewModel = this.refsByRefName[fullRefName];
  if (!refViewModel && constructIfUnavailable) {
    refViewModel = this.refsByRefName[fullRefName] = new RefViewModel({ name: fullRefName, graph: this });
    this.refs.push(refViewModel);
  }
  return refViewModel;
}
GitGraphViewModel.prototype.getEdge = function(nodeAsha1, nodeBsha1) {
  var id = nodeAsha1 + '-' + nodeBsha1;
  var edge = this.edgesById[id];
  if (!edge) {
    edge = this.edgesById[id] = new EdgeViewModel(this.getNode(nodeAsha1), this.getNode(nodeBsha1));
  }
  return edge;
}

GitGraphViewModel.getHEAD = function(nodes) {
  return _.find(nodes, function(node) { return _.find(node.refs(), 'isLocalHEAD'); });
}

GitGraphViewModel.traverseNodeParents = function(node, nodesById, callback) {
  if (node.index() >= this.maxNNodes) return false;
  if (!callback(node)) return false;
  for (var i=0; i < node.parents().length; i++) {
    var parent = nodesById[node.parents()[i]];
    if (parent)
      GitGraphViewModel.traverseNodeParents(parent, nodesById, callback);
  }
}
GitGraphViewModel.traverseNodeLeftParents = function(node, nodesById, callback) {
  if (node.index() >= this.maxNNodes) return;
  callback(node);
  var parent = nodesById[node.parents()[0]];
  if (parent)
    GitGraphViewModel.traverseNodeLeftParents(parent, nodesById, callback);
}

GitGraphViewModel._markIdeologicalStamp = 0;
GitGraphViewModel.markNodesIdeologicalBranches = function(refs, nodes, nodesById) {
  refs = refs.filter(function(r) { return !!r.node(); });
  refs = refs.sort(function(a, b) {
    if (a.isLocal && !b.isLocal) return -1;
    if (b.isLocal && !a.isLocal) return 1;
    if (a.isBranch && !b.isBranch) return -1;
    if (b.isBranch && !a.isBranch) return 1;
    if (a.isHead && !b.isHead) return 1;
    if (!a.isHead && b.isHead) return -1;
    if (a.isStash && !b.isStash) return 1;
    if (b.isStash && !a.isStash) return -1;
    if (a.node() && a.node().commitTime() && b.node() && b.node().commitTime())
      return a.node().commitTime() - b.node().commitTime();
    return a.refName < b.refName ? -1 : 1;
  });
  var stamp = GitGraphViewModel._markIdeologicalStamp++;
  refs.forEach(function(ref) {
    GitGraphViewModel.traverseNodeParents(ref.node(), nodesById, function(node) {
      if (node.stamp == stamp) return false;
      node.stamp = stamp;
      node.ideologicalBranch(ref);
      return true;
    });
  });
}

GitGraphViewModel.randomColor = function() {
  var randomHex = function() {
    var r = Math.floor(Math.random() * 256).toString(16);
    if (r.length == 1) r = '0' + r;
    return r;
  }
  return '#' + randomHex() + randomHex() + randomHex();
}


GitGraphViewModel.prototype.setNodes = function(nodes) {
  nodes.forEach(function(node, i) { node.index(i); });
  nodes = nodes.slice(0, GitGraphViewModel.maxNNodes);

  GitGraphViewModel.markNodesIdeologicalBranches(this.refs(), nodes, this.nodesById);
  this.HEAD(GitGraphViewModel.getHEAD(nodes));
  var HEAD = this.HEAD();

  var updateTimeStamp = moment().valueOf();

  // Mark timestamps
  if (HEAD) {
    GitGraphViewModel.traverseNodeLeftParents(HEAD, this.nodesById, function(node) {
      node.ancestorOfHEADTimeStamp = updateTimeStamp;
    });
  }

  // Filter out nodes which doesn't have a branch (staging and orphaned nodes)
  nodes = nodes.filter(function(node) { return (node.ideologicalBranch() && !node.ideologicalBranch().isStash) || node.ancestorOfHEADTimeStamp == updateTimeStamp; })

  //var concurrentBranches = { };

  var branchSlots = [];

  // Then iterate from the bottom to fix the orders of the branches
  for (var i = nodes.length - 1; i >= 0; i--) {
    var node = nodes[i];
    if (node.ancestorOfHEADTimeStamp == updateTimeStamp) continue;
    var ideologicalBranch = node.ideologicalBranch();

    // First occurence of the branch, find an empty slot for the branch
    if (ideologicalBranch.lastSlottedTimeStamp != updateTimeStamp) {
      ideologicalBranch.lastSlottedTimeStamp = updateTimeStamp;
      var slot = 0;
      for(;slot < branchSlots.length; slot++)
        if (branchSlots[slot] === undefined) break;
      if (slot == branchSlots.length) {
        branchSlots.push(ideologicalBranch);
        slot = branchSlots.length - 1;
      }
      ideologicalBranch.branchOrder = slot;
      branchSlots[slot] = slot;
    }

    node.branchOrder = ideologicalBranch.branchOrder;

    // Free branch slots when we reach the end of a branch
    /*if (node == ideologicalBranch.node()) {
      branchSlots[ideologicalBranch.branchOrder] = undefined;
    }*/
  }

  var prevNode;
  nodes.forEach(function(node) {
    node.branchOrder = branchSlots.length - node.branchOrder;
    node.ancestorOfHEAD(node.ancestorOfHEADTimeStamp == updateTimeStamp);
    node.aboveNode = prevNode;
    if (prevNode) prevNode.belowNode = node;
    node.updateGoalPosition();
    prevNode = node;
  });

  this.nodes(nodes);
}

GitGraphViewModel.prototype.instantUpdatePositions = function() {
  this.nodes().forEach(function(node) {
    node.updateGoalPosition();
    node.position(node.goalPosition());
  });
}

GitGraphViewModel.prototype.handleBubbledClick = function(elem, event) {
  // If the clicked element is bound to the current action context,
  // then let's not deselect it.
  if (ko.dataFor(event.target) === this.currentActionContext()) return;
  if (this.currentActionContext() && this.currentActionContext() instanceof GitNodeViewModel) {
    this.currentActionContext().toggleSelected();
  } else {
    this.currentActionContext(null);
  }
  // If the click was on an input element, then let's allow the default action to proceed.
  // This is especially needed since for some strange reason any submit (ie. enter in a textbox)
  // will trigger a click event on the submit input of the form, which will end up here,
  // and if we don't return true, then the submit event is never fired, breaking stuff.
  if (event.target.nodeName === 'INPUT') return true;
}

},{"./git-node":3,"./graph-graphics/edge":6,"./graph-graphics/graph":7,"./ref.js":9,"knockout":"knockout","lodash":"lodash","moment":"moment","ungit-components":"ungit-components","ungit-vector2":"ungit-vector2"}],2:[function(require,module,exports){

var ko = require('knockout');
var inherits = require('util').inherits;
var components = require('ungit-components');
var RefViewModel = require('./ref.js').RefViewModel;
var graphGraphicsActions = require('./graph-graphics/actions');
var RebaseViewModel = graphGraphicsActions.RebaseViewModel;
var MergeViewModel = graphGraphicsActions.MergeViewModel;
var ResetViewModel = graphGraphicsActions.ResetViewModel;
var PushViewModel = graphGraphicsActions.PushViewModel;
var programEvents = require('ungit-program-events');

var GraphActions = {};
module.exports = GraphActions;

GraphActions.ActionBase = function(graph) {
  var self = this;
  this.graph = graph;
  this.server = graph.server;
  this.performProgressBar = components.create('progressBar', {
    predictionMemoryKey: 'action-' + this.style + '-' + graph.repoPath,
    fallbackPredictedTimeMs: 1000,
    temporary: true
  });

  this.isHighlighted = ko.computed(function() {
    return !graph.hoverGraphAction() || graph.hoverGraphAction() == self;
  });
  this.cssClasses = ko.computed(function() {
    var c = self.style;
    if (!self.isHighlighted()) c += ' dimmed';
    return c;
  })
}
GraphActions.ActionBase.prototype.icon = null;
GraphActions.ActionBase.prototype.doPerform = function() {
  var self = this;
  this.graph.hoverGraphAction(null);
  self.performProgressBar.start();
  this.perform(function() {
    self.performProgressBar.stop();
  });
}
GraphActions.ActionBase.prototype.dragEnter = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.dragLeave = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(null);
}
GraphActions.ActionBase.prototype.mouseover = function() {
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.mouseout = function() {
  this.graph.hoverGraphAction(null);
}

GraphActions.Move = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Move, GraphActions.ActionBase);
GraphActions.Move.prototype.text = 'Move';
GraphActions.Move.prototype.style = 'move';
GraphActions.Move.prototype.icon = 'glyphicon-move';
GraphActions.Move.prototype.perform = function(callback) {
  this.graph.currentActionContext().moveTo(this.node.sha1, callback);
}


GraphActions.Reset = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.onto = ko.observable(this.node);
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (!(self.graph.currentActionContext() instanceof RefViewModel)) return false;
    var context = self.graph.currentActionContext();
    if (context.node() != self.node) return false;
    var remoteRef = context.getRemoteRef(self.graph.currentRemote());
    return remoteRef &&
      remoteRef.node() != context.node() &&
      remoteRef.node().commitTime() < context.node().commitTime();
  });
}
inherits(GraphActions.Reset, GraphActions.ActionBase);
GraphActions.Reset.prototype.text = 'Reset';
GraphActions.Reset.prototype.style = 'reset';
GraphActions.Reset.prototype.icon = 'glyphicon-trash';
GraphActions.Reset.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  var nodes = context.node().getPathToCommonAncestor(remoteRef.node()).slice(0, -1);
  return new ResetViewModel(nodes);
}
GraphActions.Reset.prototype.perform = function(callback) {
  var server = this.server;
  var context = this.graph.currentActionContext();
  var remote = this.graph.currentRemote();
  var repoPath = this.graph.repoPath;
  var diag = components.create('yesnodialog', { title: 'Are you sure?', details: 'This operation cannot be undone with ungit.'});
  diag.closed.add(function() {
    if (diag.result()) {
		var remoteRef = context.getRemoteRef(remote);
        server.post('/reset', { path: repoPath, to: remoteRef.name, mode: 'hard' }, callback);
	} else {
		callback();
	}
  });
  programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
}

GraphActions.Rebase = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      (!ungit.config.showRebaseAndMergeOnlyOnRefs || self.node.refs().length > 0) &&
      self.graph.currentActionContext().current() &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Rebase, GraphActions.ActionBase);
GraphActions.Rebase.prototype.text = 'Rebase';
GraphActions.Rebase.prototype.style = 'rebase';
GraphActions.Rebase.prototype.createHoverGraphic = function() {
  var onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();
  var path = onto.getPathToCommonAncestor(this.node);
  return new RebaseViewModel(this.node, path);
}
GraphActions.Rebase.prototype.perform = function(callback) {
  this.server.post('/rebase', { path: this.graph.repoPath, onto: this.node.sha1 }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}


GraphActions.Merge = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.mergeWith = ko.observable(this.node);
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (!self.graph.checkedOutRef() || !self.graph.checkedOutRef().node()) return false;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      !self.graph.currentActionContext().current() &&
      self.graph.checkedOutRef().node() == self.node;
  });
}
inherits(GraphActions.Merge, GraphActions.ActionBase);
GraphActions.Merge.prototype.text = 'Merge';
GraphActions.Merge.prototype.style = 'merge';
GraphActions.Merge.prototype.createHoverGraphic = function() {
  var node = this.graph.currentActionContext();
  if (!node) return null;
  if (node instanceof RefViewModel) node = node.node();
  return new MergeViewModel(this.graph.graphic, this.node, node);
}
GraphActions.Merge.prototype.perform = function(callback) {
  this.server.post('/merge', { path: this.graph.repoPath, with: this.graph.currentActionContext().localRefName }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}

GraphActions.Push = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      self.graph.currentActionContext().canBePushed(self.graph.currentRemote());
  });
}
inherits(GraphActions.Push, GraphActions.ActionBase);
GraphActions.Push.prototype.text = 'Push';
GraphActions.Push.prototype.style = 'push';
GraphActions.Push.prototype.icon = 'glyphicon-open';
GraphActions.Push.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  if (!remoteRef) return null;
  return new PushViewModel(remoteRef.node(), context.node());
}
GraphActions.Push.prototype.perform = function( callback) {
  var self = this;
  var programEventListener = function(event) {
    if (event.event == 'request-credentials') self.performProgressBar.pause();
    else if (event.event == 'request-credentials-response') self.performProgressBar.unpause();
  };
  programEvents.add(programEventListener);
  var ref = this.graph.currentActionContext();
  var onDone = function(err) {
    programEvents.remove(programEventListener);
    callback();
    if (!err) {
      self.graph.loadNodesFromApi();
      if (ref.isTag) {
        programEvents.dispatch({ event: 'request-fetch-tags' });
      }
    }
  }
  var remoteRef = ref.getRemoteRef(this.graph.currentRemote());
  if (remoteRef) remoteRef.moveTo(ref.refName, onDone);
  else ref.createRemoteRef(onDone);
}

GraphActions.Checkout = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (self.graph.currentActionContext() instanceof RefViewModel)
      return self.graph.currentActionContext().node() == self.node &&
        !self.graph.currentActionContext().current();
    return ungit.config.allowCheckoutNodes &&
      self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Checkout, GraphActions.ActionBase);
GraphActions.Checkout.prototype.text = 'Checkout';
GraphActions.Checkout.prototype.style = 'checkout';
GraphActions.Checkout.prototype.icon = 'glyphicon-folder-open';
GraphActions.Checkout.prototype.perform = function(callback) {
  var self = this;
  var context = this.graph.currentActionContext();
  var refName;
  if (context instanceof RefViewModel) refName = context.refName;
  else refName = context.sha1;
  this.server.post('/checkout', { path: this.graph.repoPath, name: refName }, function(err) {
    if (err && err.errorCode != 'merge-failed') {
      callback();
      return;
    }
    if (context instanceof RefViewModel && context.isRemoteBranch)
      self.server.post('/reset', { path: self.graph.repoPath, to: context.name, mode: 'hard' }, function(err, res) {
        callback();
        if (err && err.errorCode != 'merge-failed') return;
        return true;
      });
    else
      callback();
    return true;
  });
}

GraphActions.Delete = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      !self.graph.currentActionContext().current();
  });
}
inherits(GraphActions.Delete, GraphActions.ActionBase);
GraphActions.Delete.prototype.text = 'Delete';
GraphActions.Delete.prototype.style = 'delete';
GraphActions.Delete.prototype.icon = 'glyphicon-remove';
GraphActions.Delete.prototype.perform = function(callback) {
  var context = this.graph.currentActionContext();
  var diag = components.create('yesnodialog', { title: 'Are you sure?', details: 'This operation cannot be undone with ungit.'});
  diag.closed.add(function() {
    if (diag.result()) {
		context.remove(callback);
	} else {
		callback();
	}
  });
  programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
}


GraphActions.CherryPick = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node
  });
}
inherits(GraphActions.CherryPick, GraphActions.ActionBase);
GraphActions.CherryPick.prototype.text = 'Cherry pick';
GraphActions.CherryPick.prototype.style = 'cherry-pick';
GraphActions.CherryPick.prototype.perform = function(callback) {
  var self = this;
  this.server.post('/cherrypick', { path: this.graph.repoPath, name: this.node.sha1 }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}

GraphActions.Uncommit = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node &&
      self.graph.HEAD() == self.node;
  });
}
inherits(GraphActions.Uncommit, GraphActions.ActionBase);
GraphActions.Uncommit.prototype.text = 'Uncommit';
GraphActions.Uncommit.prototype.style = 'uncommit';
GraphActions.Uncommit.prototype.perform = function(callback) {
  var self = this;
  this.server.post('/reset', { path: this.graph.repoPath, to: 'HEAD^', mode: 'mixed' }, callback);
}

GraphActions.Revert = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Revert, GraphActions.ActionBase);
GraphActions.Revert.prototype.text = 'Revert';
GraphActions.Revert.prototype.style = 'revert';
GraphActions.Revert.prototype.perform = function(callback) {
  var self = this;
  this.server.post('/revert', { path: this.graph.repoPath, commit: this.node.sha1 }, callback);
}

},{"./graph-graphics/actions":5,"./ref.js":9,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events","util":undefined}],3:[function(require,module,exports){
var ko = require('knockout');
var inherits = require('util').inherits;
var Selectable = require('./git-selectable').Selectable;
var GraphActions = require('./git-graph-actions');
var NodeViewModel = require('./graph-graphics/node').NodeViewModel;
var components = require('ungit-components');
var Vector2 = require('ungit-vector2');

var GitNodeViewModel = function(graph, sha1) {
  NodeViewModel.call(this);
  Selectable.call(this, graph);
  var self = this;

  this.graph = graph;
  this.server = graph.server;
  this.sha1 = sha1;

  this.isInited = false;

  this.boxDisplayX = ko.computed(function() {
    return self.x();
  });
  this.boxDisplayY = ko.computed(function() {
    return self.y();
  });
  this.commitContainerX = ko.computed(function() {
    return -self.radius();
  })
  this.refsX = ko.computed(function() {
    return self.radius();
  });
  this.nodeX = ko.computed(function() {
    return -self.radius();
  });
  this.nodeY = ko.computed(function() {
    return -self.radius();
  });
  this.nodeWidth = ko.computed(function() {
    return self.radius()*2;
  });
  this.nodeHeight = ko.computed(function() {
    return self.radius()*2;
  });
  this.aboveNode = null; // The node directly above this, graphically

  this.parents = ko.observable([]);
  this.title = ko.observable();
  this.commitTime = ko.observable();

  this.commitComponent = components.create('commit', {
    sha1: sha1,
    repoPath: this.graph.repoPath,
    server: graph.server
  });

  this.boxDisplayX.subscribe(function(value) {
    self.commitComponent.selectedDiffLeftPosition(-value);
  });

  this.index = ko.observable();
  this.ideologicalBranch = ko.observable();
  self.ideologicalBranch.subscribe(function(value) {
    self.color(value ? value.color : '#666');
  });
  this.ancestorOfHEAD = ko.observable(false);
  this.nodeIsMousehover = ko.observable(false);
  this.nodeIsMousehover.subscribe(function(value) {
    self.commitComponent.nodeIsMousehover(value);
  });
  this.commitContainerVisible = ko.computed(function() {
    return (self.ancestorOfHEAD() && self.isAtFinalXPosition()) || self.nodeIsMousehover() || self.selected();
  });
  this.highlighted = ko.computed(function() {
    return self.nodeIsMousehover() || self.selected();
  });
  this.highlighted.subscribe(function(value) {
    self.commitComponent.highlighted(value);
  });
  this.selected.subscribe(function(value) {
    self.commitComponent.selected(value);
  });
  // These are split up like this because branches and local tags can be found in the git log,
  // whereas remote tags needs to be fetched with another command (which is much slower)
  this.branchesAndLocalTags = ko.observable([]);
  this.remoteTags = ko.observable([]);
  this.refs = ko.computed(function() {
    var rs = self.branchesAndLocalTags().concat(self.remoteTags());
    rs.sort(function(a, b) {
      if (a.isLocal && !b.isLocal) return -1;
      if (!a.isLocal && b.isLocal) return 1;
      return a.refName < b.refName ? -1 : 1;
    });
    return rs;
  });
  this.branches = ko.computed(function() {
    return self.refs().filter(function(r) { return r.isBranch; });
  });
  this.tags = ko.computed(function() {
    return self.refs().filter(function(r) { return r.isTag; });
  });
  this.showNewRefAction = ko.computed(function() {
    return !graph.currentActionContext();
  })
  this.newBranchName = ko.observable();
  this.newBranchNameHasFocus = ko.observable(true);
  this.newBranchNameHasFocus.subscribe(function(newValue) {
    if (!newValue) {
      // Small timeout because in ff the form is hidden before the submit click event is registered otherwise
      setTimeout(function() {
        self.branchingFormVisible(false);
      }, 200);
    }
  })
  this.branchingFormVisible = ko.observable(false);
  this.canCreateRef = ko.computed(function() {
    return self.newBranchName() && self.newBranchName().trim() && self.newBranchName().indexOf(' ') == -1;
  });

  this.dropareaGraphActions = [
    new GraphActions.Move(this.graph, this),
    new GraphActions.Rebase(this.graph, this),
    new GraphActions.Merge(this.graph, this),
    new GraphActions.Push(this.graph, this),
    new GraphActions.Reset(this.graph, this),
    new GraphActions.Checkout(this.graph, this),
    new GraphActions.Delete(this.graph, this),
    new GraphActions.CherryPick(this.graph, this),
    new GraphActions.Uncommit(this.graph, this),
    new GraphActions.Revert(this.graph, this)
  ];
}
inherits(GitNodeViewModel, NodeViewModel);
exports.GitNodeViewModel = GitNodeViewModel;
GitNodeViewModel.prototype.setData = function(args) {
  var self = this;
  this.parents(args.parents || []);
  this.commitTime(args.commitDate);
  this.title(args.message.split('\n')[0]);
  this.commitComponent.setData(args);
}
GitNodeViewModel.prototype.updateAnimationFrame = function(deltaT) {
  this.commitComponent.updateAnimationFrame(deltaT);
  GitNodeViewModel.super_.prototype.updateAnimationFrame.call(this, deltaT);

  this.updateGoalPosition();
}
GitNodeViewModel.prototype.updateGoalPosition = function() {
  var goalPosition = new Vector2();
  if (this.ancestorOfHEAD()) {
    if (!this.aboveNode)
      goalPosition.y = 120;
    else if (this.aboveNode.ancestorOfHEAD())
      goalPosition.y = this.aboveNode.goalPosition().y + 120;
    else
      goalPosition.y = this.aboveNode.goalPosition().y + 60;
    goalPosition.x = 30;
    this.setRadius(30);
  } else {
    if (this.aboveNode) {
      goalPosition.y = this.aboveNode.goalPosition().y + 60;
    } else {
      goalPosition.y = 120;
    }

    goalPosition.x = 30 + 90 * this.branchOrder;
    this.setRadius(15);
  }
  if (this.aboveNode && this.aboveNode.selected()) {
    goalPosition.y = this.aboveNode.goalPosition().y + this.aboveNode.commitComponent.element().offsetHeight + 30;
  }
  this.setPosition(goalPosition);
}
GitNodeViewModel.prototype.showBranchingForm = function() {
  this.branchingFormVisible(true);
  this.newBranchNameHasFocus(true);
}
GitNodeViewModel.prototype.createBranch = function() {
  if (!this.canCreateRef()) return;
  this.server.post('/branches', { path: this.graph.repoPath, name: this.newBranchName(), startPoint: this.sha1 });
  this.branchingFormVisible(false);
  this.newBranchName('');
}
GitNodeViewModel.prototype.createTag = function() {
  if (!this.canCreateRef()) return;
  this.server.post('/tags', { path: this.graph.repoPath, name: this.newBranchName(), startPoint: this.sha1 });
  this.branchingFormVisible(false);
  this.newBranchName('');
}
GitNodeViewModel.prototype.isAncestor = function(node) {
  if (this.index() >= this.graph.maxNNodes) return false;
  if (node == this) return true;
  for (var v in this.parents()) {
    var n = this.graph.nodesById[this.parents()[v]];
    if (n && n.isAncestor(node)) return true;
  }
  return false;
}
GitNodeViewModel.prototype.getPathToCommonAncestor = function(node) {
  var path = [];
  var thisNode = this;
  while (thisNode && !node.isAncestor(thisNode)) {
    path.push(thisNode);
    thisNode = this.graph.nodesById[thisNode.parents()[0]];
  }
  if (thisNode)
    path.push(thisNode);
  return path;
}
GitNodeViewModel.prototype.toggleSelected = function() {
  var self = this;
  var beforeThisCR = this.commitComponent.element().getBoundingClientRect();
  var beforeBelowCR = null;
  if (this.belowNode)
    beforeBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();

  var prevSelected  = this.graph.currentActionContext();
  if (!(prevSelected instanceof GitNodeViewModel)) prevSelected = null;
  var prevSelectedCR = null;
  if (prevSelected) prevSelectedCR = prevSelected.commitComponent.element().getBoundingClientRect();
  this.selected(!this.selected());

  this.graph.instantUpdatePositions();
  // If we are deselecting
  if (!this.selected()) {
    if (beforeThisCR.top < 0 && beforeBelowCR) {
      var afterBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
      // If the next node is showing, try to keep it in the screen (no jumping)
      if (beforeBelowCR.top < window.innerHeight) {
        window.scrollBy(0, afterBelowCR.top - beforeBelowCR.top);
      // Otherwise just try to bring them to the middle of the screen
      } else {
        window.scrollBy(0, afterBelowCR.top - window.innerHeight / 2);
      }
    }
  // If we are selecting
  } else {
    var afterThisCR = this.commitComponent.element().getBoundingClientRect();
    if ((prevSelectedCR && (prevSelectedCR.top < 0 || prevSelectedCR.top > window.innerHeight)) &&
      afterThisCR.top != beforeThisCR.top) {
      window.scrollBy(0, -(beforeThisCR.top - afterThisCR.top));
      console.log('Fix')
    }
  }
}
GitNodeViewModel.prototype.nodeMouseover = function() {
  this.nodeIsMousehover(true);
}
GitNodeViewModel.prototype.nodeMouseout = function() {
  this.nodeIsMousehover(false);
}


},{"./git-graph-actions":2,"./git-selectable":4,"./graph-graphics/node":8,"knockout":"knockout","ungit-components":"ungit-components","ungit-vector2":"ungit-vector2","util":undefined}],4:[function(require,module,exports){
var ko = require('knockout');
var _ = require('lodash');

var Selectable = function(graph) {
  this.selected = ko.computed({
    read: function() {
      return graph.currentActionContext() == this;
    },
    write: function(val) {
      // val is this if we're called from a click ko binding
      if (val === this || val === true) {
        graph.currentActionContext(this);
      } else if (graph.currentActionContext() == this) {
        graph.currentActionContext(null);
      }
    },
    owner: this
  });
};
exports.Selectable = Selectable;

},{"knockout":"knockout","lodash":"lodash"}],5:[function(require,module,exports){

var ko = require('knockout');
var Vector2 = require('ungit-vector2');
var NodeViewModel = require('./node').NodeViewModel;
var EdgeViewModel = require('./edge').EdgeViewModel;
var Color = require('color');


function MergeViewModel(graph, headNode, node) {
  var self = this;

  this.graph = graph;

  var newNode = {
    position: new Vector2(
      headNode.x(),
      headNode.y() - 35),
    radius: Math.max(headNode.radius(), node.radius())
  };
  newNode.position.y -= newNode.radius*2;

  this.newNode = new NodeViewModel(newNode.position, newNode.radius);
  this.edges = [
    new EdgeViewModel(headNode, this.newNode),
    new EdgeViewModel(node, this.newNode)
  ];
  graph.dimCommit(true)
}
exports.MergeViewModel = MergeViewModel;
MergeViewModel.prototype.type = 'merge';
MergeViewModel.prototype.destroy = function() {
  this.graph.dimCommit(false)
}


function RebaseViewModel(onto, nodesThatWillMove) {
  var self = this;
  
  var rebaseNodes = {};
  this.path = nodesThatWillMove;
  this.path.slice(0, -1).forEach(function(node) { rebaseNodes[node.sha1] = true; });

  this.arrows = [];
  this.nodes = this.path.slice(0, -1).map(function(node, i) {
    i = (self.path.length - 1 - i);
    var n = new NodeViewModel(
      new Vector2(
        onto.x() + (node.x() - self.path[self.path.length - 1].x()),
        onto.y() - i * (node.radius() * 2 + 20)),
      node.radius());
    var d = n.position().sub(node.position()).normalize();
    var from = node.position().add(d.mul(node.radius() + 3));
    var to = n.position().sub(d.mul(node.radius()));
    var l = to.sub(from).length();
    if (l > 45) to = to.sub(d.mul(45));
    else to = from.add(d);
    self.arrows.push({ from: from, to: to });
    return n;
  });

  this.edges = [];
  var prevNode = onto;
  this.nodes.reverse().forEach(function(node) {
    self.edges.push(new EdgeViewModel(node, prevNode));
    prevNode = node;
  });

  this.path.slice(0, -1).forEach(function(node) {
    node.savedColor = node.color();
    node.color(Color(node.color()).alpha(0.2).rgbaString());
  });
}
exports.RebaseViewModel = RebaseViewModel;
RebaseViewModel.prototype.type = 'rebase';
RebaseViewModel.prototype.destroy = function() {
  this.path.slice(0, -1).forEach(function(node) {
    node.color(node.savedColor);
  });
}
RebaseViewModel.prototype.updateAnimationFrame = function(deltaT) {
  this.nodes.forEach(function(node) {
    node.updateAnimationFrame(deltaT);
  });
}


function ResetViewModel(nodes) {
  this.nodes = nodes;
}
exports.ResetViewModel = ResetViewModel;
ResetViewModel.prototype.type = 'reset';


function PushViewModel(fromNode, toNode) {
  this.fromPosition = fromNode.position().clone();
  this.toPosition = toNode.position().clone();
  this.fromPosition.x += fromNode.radius() + 50;
  this.toPosition.x += toNode.radius() + 50;
  if (this.fromPosition.y > this.toPosition.y) {
    this.fromPosition.y -= 20;
    this.toPosition.y += 20;
  } else {
    this.fromPosition.y += 20;
    this.toPosition.y -= 20;
  }
  // adjust for the arrow
  var d = this.toPosition.sub(this.fromPosition).normalize();
  this.toPosition = this.toPosition.sub(d.mul(45));
}
exports.PushViewModel = PushViewModel;
PushViewModel.prototype.type = 'push';
},{"./edge":6,"./node":8,"color":undefined,"knockout":"knockout","ungit-vector2":"ungit-vector2"}],6:[function(require,module,exports){

var ko = require('knockout');
var Vector2 = require('ungit-vector2');

var EdgeViewModel = function(nodea, nodeb) {
  var self = this;
  this.nodea = ko.observable(nodea);
  this.nodeb = ko.observable(nodeb);
  this.x1 = ko.observable();
  this.x2 = ko.observable();
  this.y1 = ko.observable();
  this.y2 = ko.observable();
  this.updateAnimationFrame();
}
exports.EdgeViewModel = EdgeViewModel;
EdgeViewModel.prototype._getNodePosition = function(node, fallbackNode) {
  if (node && node.position()) {
    return node.position();
  } else {
    if (fallbackNode && fallbackNode.position()) return fallbackNode.position().add(new Vector2(0, 10000));
    else return new Vector2(0, 0);
  }
}
EdgeViewModel.prototype._getNodeRadius = function(node) {
  return (node ? node.outerRadius() : null) || 30;
}
EdgeViewModel.prototype.updateAnimationFrame = function(deltaT) {
  var a = this._getNodePosition(this.nodea(), this.nodeb());
  var b = this._getNodePosition(this.nodeb(), this.nodea());
  var d = b.sub(a);
  if (d.length() == 0) {
    this.x1(a.x);
    this.y1(a.y);
    this.x2(a.x);
    this.y2(a.y);
    return;
  }
  d = d.normalize();
  var p1 = a.add(d.mul(this._getNodeRadius(this.nodea()) + 2));
  var p2 = b.sub(d.mul(this._getNodeRadius(this.nodeb()) + 2));
  this.x1(p1.x);
  this.y1(p1.y);
  this.x2(p2.x);
  this.y2(p2.y);
}
},{"knockout":"knockout","ungit-vector2":"ungit-vector2"}],7:[function(require,module,exports){

var ko = require('knockout');
var Vector2 = require('ungit-vector2');
var EdgeViewModel = require('./edge').EdgeViewModel;

var GraphViewModel = function() {
  var self = this;
  this.nodes = ko.observable([]);
  this.commitNode = new CommitNodeViewModel(this);
  this.commitNodeEdge = new EdgeViewModel(this.commitNode);
  this.offset = ko.observable(new Vector2(0, 0));
  this.edges = ko.observable([]);
  this.showCommitNode = ko.observable();
  this.dimCommit = ko.observable(false);
  this.commitOpacity = ko.computed(function() { return self.dimCommit() ? 0.1 : 1; });
  this.graphWidth = ko.computed(function() {
    var width = 0;
    self.nodes().forEach(function(node) {
      width = Math.max(width, node.x() + node.radius() + self.offset().x + 200);
    });
    return width;
  });
  this.graphHeight = ko.computed(function() {
    var height = 0;
    self.nodes().forEach(function(node) {
      height = Math.max(height, node.y() + node.radius() + self.offset().y + 5);
    });
    return height;
  });

  this.hoverGraphActionGraphic = ko.observable();
  var prevHoverGraphic;
  this.hoverGraphActionGraphic.subscribe(function(value) {
    prevHoverGraphic = value;
  }, null, 'beforeChange');
  this.hoverGraphActionGraphic.subscribe(function(newValue) {
    if (newValue != prevHoverGraphic && prevHoverGraphic && prevHoverGraphic.destroy)
      prevHoverGraphic.destroy();
  });
  this.hoverGraphActionGraphicType = ko.computed(function() {
    return self.hoverGraphActionGraphic() ? self.hoverGraphActionGraphic().type : '';
  })
}
exports.GraphViewModel = GraphViewModel;
GraphViewModel.prototype.updateAnimationFrame = function(deltaT) {
  if (this.hoverGraphActionGraphic() && this.hoverGraphActionGraphic().updateAnimationFrame) {
    this.hoverGraphActionGraphic().updateAnimationFrame(deltaT);
  }
  this.nodes().forEach(function(node) {
    node.updateAnimationFrame(deltaT);
  });
  this.edges().forEach(function(edge) {
    edge.updateAnimationFrame(deltaT);
  });
  this.commitNodeEdge.updateAnimationFrame(deltaT);
}

var CommitNodeViewModel = function(graph) {
  this.position = ko.observable(new Vector2(30, 30));
  this.radius = ko.observable(28);
  this.outerRadius = ko.observable(32);
  //this.color = ko.computed(function() { return graph.HEAD() && graph.HEAD().ideologicalBranch() ? graph.HEAD().ideologicalBranch().color : '#666' });
  this.color = ko.observable('#ff00ff')
}
},{"./edge":6,"knockout":"knockout","ungit-vector2":"ungit-vector2"}],8:[function(require,module,exports){

var ko = require('knockout');
var Vector2 = require('ungit-vector2');

var NodeViewModel = function(position, radius) {
  var self = this;
  this.position = ko.observable(position);
  this.goalPosition = ko.observable(position);
  this.isAtFinalXPosition = ko.computed(function() {
    if (!self.goalPosition() || !self.position()) return true;
    return self.position().x == self.goalPosition().x;
  });
  this.x = ko.computed(function() { return self.position() ? self.position().x : 0; });
  this.y = ko.computed(function() { return self.position() ? self.position().y : 0; });
  this.radius = ko.observable(radius || 30);
  this.outerRadius = this.radius;
  this.goalRadius = ko.observable(radius);
  this.animationSpeed = 0.4;
  this.color = ko.observable('#ff00ff');
  this.selected = ko.observable(false);
}
exports.NodeViewModel = NodeViewModel;
NodeViewModel.prototype.setPosition = function(position) {
  var self = this;
  this.prevPosition = self.position();
  if (!self.goalPosition()) self.position(position);
  self.goalPosition(position);
}
NodeViewModel.prototype.setRadius = function(radius) {
  this.prevRadius = this.radius();
  if (!this.goalRadius()) this.radius(radius);
  this.goalRadius(radius);
  this.setRadiusTimestamp = Date.now();
}
NodeViewModel.prototype.updateAnimationFrame = function(deltaT) {
  var totalTime = 500;

  var d = this.goalPosition().sub(this.position() || new Vector2(0, 0));
  var distanceLeft = d.length();
  if (distanceLeft != 0) {

    d = this.goalPosition().sub(this.prevPosition || new Vector2(0, 0));

    var totalLength = d.length();
    var lengthToMove = deltaT * this.animationSpeed;
    if (distanceLeft < lengthToMove) {
      this.position(this.goalPosition());
    } else {
      d = d.normalize().mul(lengthToMove);

      var pos = (this.position() || new Vector2(0, 0)).add(d);
      this.position(pos);
    }
  }

  var radiusLeft = this.goalRadius() - this.radius();
  if (radiusLeft != 0) {
    var sign = radiusLeft ? radiusLeft < 0 ? -1 : 1 : 0;
    radiusLeft = Math.abs(radiusLeft);
    var totalRadiusDiff = Math.abs(this.goalRadius() - this.prevRadius);
    var radiusToChange = totalRadiusDiff * deltaT / totalTime;
    if (radiusLeft < radiusToChange) {
      this.radius(this.goalRadius());
    } else {
      this.radius(this.radius() + sign * radiusToChange);
    }
  }
}

},{"knockout":"knockout","ungit-vector2":"ungit-vector2"}],9:[function(require,module,exports){

var ko = require('knockout');
var md5 = require('blueimp-md5').md5;
var Selectable = require('./git-selectable').Selectable;
var programEvents = require('ungit-program-events');
var components = require('ungit-components');

var RefViewModel = function(args) {
  Selectable.call(this, args.graph);
  var self = this;
  this.node = ko.observable();
  this.boxDisplayX = ko.computed(function() {
    if (!self.node()) return 0;
    return self.node().x();
  });
  this.boxDisplayY = ko.computed(function() {
    if (!self.node()) return 0;
    return self.node().y();
  });
  this.name = args.name;
  this.localRefName = this.name; // origin/master or master
  this.refName = this.name; // master
  this.isRemoteTag = this.name.indexOf('remote-tag: ') == 0;
  this.isLocalTag = this.name.indexOf('tag: ') == 0;
  this.isTag = this.isLocalTag || this.isRemoteTag;
  var isRemoteBranchOrHEAD = this.name.indexOf('refs/remotes/') == 0;
  this.isLocalHEAD = this.name == 'HEAD';
  this.isRemoteHEAD = this.name.indexOf('/HEAD') != -1;
  this.isLocalBranch = this.name.indexOf('refs/heads/') == 0;
  this.isRemoteBranch = isRemoteBranchOrHEAD && !this.isRemoteHEAD;
  this.isStash = this.name.indexOf('refs/stash') == 0;
  this.isHEAD = this.isLocalHEAD || this.isRemoteHEAD;
  this.isBranch = this.isLocalBranch || this.isRemoteBranch;
  this.isRemote = isRemoteBranchOrHEAD || this.isRemoteTag;
  this.isLocal = this.isLocalBranch || this.isLocalTag;
  if (this.isLocalBranch) {
    this.localRefName = this.name.slice('refs/heads/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteBranch) {
    this.localRefName = this.name.slice('refs/remotes/'.length);
  }
  if (this.isLocalTag) {
    this.localRefName = this.name.slice('tag: refs/tags/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteTag) {
    this.localRefName = this.name.slice('remote-tag: '.length);
  }
  if (this.isRemote) {
    // get rid of the origin/ part of origin/branchname
    var s = this.localRefName.split('/');
    this.remote = s[0];
    this.refName = s.slice(1).join('/');
  }
  this.show = true;
  this.graph = args.graph;
  this.server = this.graph.server;
  this.localRef = ko.observable();
  this.isDragging = ko.observable(false);
  this.current = ko.computed(function() {
    return self.isLocalBranch && self.graph.checkedOutBranch() == self.refName;
  });
  this.color = args.color || this._colorFromHashOfString(this.name);
}
RefViewModel.prototype._colorFromHashOfString = function(string) {
  return '#' + md5(string).toString().slice(0, 6);
}
exports.RefViewModel = RefViewModel;
RefViewModel.prototype.dragStart = function() {
  this.graph.currentActionContext(this);
  this.isDragging(true);
  if (document.activeElement) document.activeElement.blur();
}
RefViewModel.prototype.dragEnd = function() {
  this.graph.currentActionContext(null);
  this.isDragging(false);
}
RefViewModel.prototype.canBePushed = function(remote) {
  if (!this.isLocal) return false;
  var remoteRef = this.getRemoteRef(remote);
  if (!remoteRef) return true;
  return this.node() != remoteRef.node();
}
RefViewModel.prototype.getRemoteRef = function(remote) {
  return this.graph.getRef(this.getRemoteRefFullName(remote), false);
}
RefViewModel.prototype.getRemoteRefFullName = function(remote) {
  if (this.isLocalBranch) return 'refs/remotes/' + remote + '/' + this.refName;
  if (this.isLocalTag) return 'remote-tag: ' + remote + '/' + this.refName;
  return null;
}
RefViewModel.prototype.remove = function(callback) {
  var self = this;
  var url = this.isTag ? '/tags' : '/branches';
  if (this.isRemote) url = '/remote' + url;
  this.server.del(url, { path: this.graph.repoPath, remote: this.isRemote ? this.remote : null, name: this.refName }, function(err) {
    callback();
    self.graph.loadNodesFromApi();
    if (url == '/remote/tags') {
      programEvents.dispatch({ event: 'request-fetch-tags' });
    }
  });
}
RefViewModel.prototype.moveTo = function(target, callback) {
  var self = this;
  if (this.isLocal) {
    if (this.current())
      this.server.post('/reset', { path: this.graph.repoPath, to: target, mode: 'hard' }, callback);
    else if (this.isTag)
      this.server.post('/tags', { path: this.graph.repoPath, name: this.refName, startPoint: target, force: true }, callback);
    else
      this.server.post('/branches', { path: this.graph.repoPath, name: this.refName, startPoint: target, force: true }, callback);
  } else {
    var pushReq = { path: this.graph.repoPath, remote: this.remote,
      refSpec: target, remoteBranch: this.refName };
    this.server.post('/push', pushReq, function(err, res) {
        if (err) {
          if (err.errorCode == 'non-fast-forward') {
            var forcePushDialog = components.create('yesnodialog', { title: 'Force push?', details: 'The remote branch can\'t be fast-forwarded.' });
            forcePushDialog.closed.add(function() {
              if (!forcePushDialog.result()) return callback();
              pushReq.force = true;
              self.server.post('/push', pushReq, callback);
            });
            programEvents.dispatch({ event: 'request-show-dialog', dialog: forcePushDialog });
            return true;
          } else {
            callback(err, res);
          }
        } else {
          callback();
        }
      });
  }
}
RefViewModel.prototype.createRemoteRef = function(callback) {
  this.server.post('/push', { path: this.graph.repoPath, remote: this.graph.currentRemote(),
      refSpec: this.refName, remoteBranch: this.refName }, callback);
}
},{"./git-selectable":4,"blueimp-md5":"blueimp-md5","knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2dyYXBoLmpzIiwiY29tcG9uZW50cy9ncmFwaC9naXQtZ3JhcGgtYWN0aW9ucy5qcyIsImNvbXBvbmVudHMvZ3JhcGgvZ2l0LW5vZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2dpdC1zZWxlY3RhYmxlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9ncmFwaC1ncmFwaGljcy9hY3Rpb25zLmpzIiwiY29tcG9uZW50cy9ncmFwaC9ncmFwaC1ncmFwaGljcy9lZGdlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9ncmFwaC1ncmFwaGljcy9ncmFwaC5qcyIsImNvbXBvbmVudHMvZ3JhcGgvZ3JhcGgtZ3JhcGhpY3Mvbm9kZS5qcyIsImNvbXBvbmVudHMvZ3JhcGgvcmVmLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlxuXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIFZlY3RvcjIgPSByZXF1aXJlKCd1bmdpdC12ZWN0b3IyJyk7XG52YXIgR2l0Tm9kZVZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZ2l0LW5vZGUnKS5HaXROb2RlVmlld01vZGVsO1xudmFyIFJlZlZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vcmVmLmpzJykuUmVmVmlld01vZGVsO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIEdyYXBoVmlld01vZGVsID0gcmVxdWlyZSgnLi9ncmFwaC1ncmFwaGljcy9ncmFwaCcpLkdyYXBoVmlld01vZGVsO1xudmFyIEVkZ2VWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2dyYXBoLWdyYXBoaWNzL2VkZ2UnKS5FZGdlVmlld01vZGVsO1xuXG5jb21wb25lbnRzLnJlZ2lzdGVyKCdncmFwaCcsIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBHaXRHcmFwaFZpZXdNb2RlbChhcmdzLnNlcnZlciwgYXJncy5yZXBvUGF0aCk7XG59KTtcblxudmFyIEdpdEdyYXBoVmlld01vZGVsID0gZnVuY3Rpb24oc2VydmVyLCByZXBvUGF0aCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gIHRoaXMuY3VycmVudFJlbW90ZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5tYXhOTm9kZXMgPSAyNTtcbiAgdGhpcy5ub2RlcyA9IGtvLm9ic2VydmFibGUoW10pO1xuICB0aGlzLmVkZ2VzQnlJZCA9IHt9O1xuICB0aGlzLnJlZnMgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgdGhpcy5ub2Rlc0J5SWQgPSB7fTtcbiAgdGhpcy5yZWZzQnlSZWZOYW1lID0ge307XG4gIHRoaXMubm9kZXNMb2FkZXIgPSBjb21wb25lbnRzLmNyZWF0ZSgncHJvZ3Jlc3NCYXInLCB7XG4gICAgICBwcmVkaWN0aW9uTWVtb3J5S2V5OiAnZ2l0Z3JhcGgtJyArIHNlbGYucmVwb1BhdGgsXG4gICAgICBmYWxsYmFja1ByZWRpY3RlZFRpbWVNczogMTAwMCxcbiAgICAgIHRlbXBvcmFyeTogdHJ1ZVxuICAgIH0pO1xuICB0aGlzLmNoZWNrZWRPdXRCcmFuY2ggPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY2hlY2tlZE91dFJlZiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmNoZWNrZWRPdXRCcmFuY2goKSlcbiAgICAgIHJldHVybiBzZWxmLmdldFJlZigncmVmcy9oZWFkcy8nICsgc2VsZi5jaGVja2VkT3V0QnJhbmNoKCkpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgdGhpcy5IRUFEID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb24gPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuc2Nyb2xsZWRUb0VuZCA9IF8uZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5tYXhOTm9kZXMgPSBzZWxmLm1heE5Ob2RlcyArIDI1O1xuICAgIHNlbGYubG9hZE5vZGVzRnJvbUFwaSgpO1xuICB9LCAxMDAwLCB0cnVlKTtcbiAgdGhpcy5ncmFwaGljID0gbmV3IEdyYXBoVmlld01vZGVsKCk7XG4gIHRoaXMuZ3JhcGhpYy5vZmZzZXQobmV3IFZlY3RvcjIoNSwgMjAwKSk7XG4gIHRoaXMuSEVBRC5zdWJzY3JpYmUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICBzZWxmLmdyYXBoaWMuY29tbWl0Tm9kZUVkZ2Uubm9kZWIodmFsdWUpO1xuICAgIHNlbGYuZ3JhcGhpYy5zaG93Q29tbWl0Tm9kZSghIXZhbHVlKTtcbiAgICBpZiAodmFsdWUpXG4gICAgICBzZWxmLmdyYXBoaWMuY29tbWl0Tm9kZS5jb2xvcih2YWx1ZS5jb2xvcigpKTtcbiAgfSk7XG5cbiAgdGhpcy5ub2Rlcy5zdWJzY3JpYmUoZnVuY3Rpb24obm9kZXMpIHtcbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUucGFyZW50cygpLmZvckVhY2goZnVuY3Rpb24ocGFyZW50U2hhMSkge1xuICAgICAgICBlZGdlcy5wdXNoKHNlbGYuZ2V0RWRnZShub2RlLnNoYTEsIHBhcmVudFNoYTEpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNlbGYuZ3JhcGhpYy5ub2Rlcyhub2Rlcyk7XG4gICAgc2VsZi5ncmFwaGljLmVkZ2VzKGVkZ2VzKTtcbiAgfSk7XG5cbiAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uLnN1YnNjcmliZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmNyZWF0ZUhvdmVyR3JhcGhpYylcbiAgICAgICAgc2VsZi5ncmFwaGljLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljKHZhbHVlLmNyZWF0ZUhvdmVyR3JhcGhpYygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5ncmFwaGljLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljKG51bGwpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpVGhyb3R0bGVkID0gXy50aHJvdHRsZSh0aGlzLmxvYWROb2Rlc0Zyb21BcGkuYmluZCh0aGlzKSwgNTAwKTtcbiAgdGhpcy51cGRhdGVCcmFuY2hlc1Rocm90dGxlZCA9IF8udGhyb3R0bGUodGhpcy51cGRhdGVCcmFuY2hlcy5iaW5kKHRoaXMpLCA1MDApO1xuICB0aGlzLmxvYWROb2Rlc0Zyb21BcGlUaHJvdHRsZWQoKTtcbiAgdGhpcy51cGRhdGVCcmFuY2hlc1Rocm90dGxlZCgpO1xufVxuR2l0R3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZU5vZGUgPSBmdW5jdGlvbihwYXJlbnRFbGVtZW50KSB7XG4gIGtvLnJlbmRlclRlbXBsYXRlKCdncmFwaCcsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbn1cbmV4cG9ydHMuR2l0R3JhcGhWaWV3TW9kZWwgPSBHaXRHcmFwaFZpZXdNb2RlbDtcbkdpdEdyYXBoVmlld01vZGVsLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGRlbHRhVCkge1xuICB0aGlzLmdyYXBoaWMudXBkYXRlQW5pbWF0aW9uRnJhbWUoZGVsdGFUKTtcbn1cbkdpdEdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5vblByb2dyYW1FdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmIChldmVudC5ldmVudCA9PSAnZ2l0LWRpcmVjdG9yeS1jaGFuZ2VkJykge1xuICAgIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCgpO1xuICAgIHRoaXMudXBkYXRlQnJhbmNoZXNUaHJvdHRsZWQoKTtcbiAgfSBlbHNlIGlmIChldmVudC5ldmVudCA9PSAncmVxdWVzdC1hcHAtY29udGVudC1yZWZyZXNoJykge1xuICAgIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCgpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdyZW1vdGUtdGFncy11cGRhdGUnKSB7XG4gICAgdGhpcy5zZXRSZW1vdGVUYWdzKGV2ZW50LnRhZ3MpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09ICdjdXJyZW50LXJlbW90ZS1jaGFuZ2VkJykge1xuICAgIHRoaXMuY3VycmVudFJlbW90ZShldmVudC5uZXdSZW1vdGUpO1xuICB9XG59XG5HaXRHcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUubG9hZE5vZGVzRnJvbUFwaSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5ub2Rlc0xvYWRlci5zdGFydCgpO1xuICB0aGlzLnNlcnZlci5nZXQoJy9sb2cnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgsIGxpbWl0OiB0aGlzLm1heE5Ob2RlcyB9LCBmdW5jdGlvbihlcnIsIGxvZ0VudHJpZXMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzZWxmLm5vZGVzTG9hZGVyLnN0b3AoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBlcnIuZXJyb3JDb2RlID09ICduby1zdWNoLXBhdGgnO1xuICAgIH1cbiAgICBzZWxmLnNldE5vZGVzRnJvbUxvZyhsb2dFbnRyaWVzKTtcbiAgICBzZWxmLm5vZGVzTG9hZGVyLnN0b3AoKTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gIH0pO1xufVxuR2l0R3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZUJyYW5jaGVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIuZ2V0KCcvY2hlY2tvdXQnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGggfSwgZnVuY3Rpb24oZXJyLCBicmFuY2gpIHtcbiAgICBpZiAoZXJyICYmIGVyci5lcnJvckNvZGUgPT0gJ25vdC1hLXJlcG9zaXRvcnknKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyKSByZXR1cm47XG4gICAgc2VsZi5jaGVja2VkT3V0QnJhbmNoKGJyYW5jaCk7XG4gIH0pO1xufVxuXG5HaXRHcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuc2V0UmVtb3RlVGFncyA9IGZ1bmN0aW9uKHJlbW90ZVRhZ3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbm9kZUlkc1RvUmVtb3RlVGFncyA9IHt9O1xuICByZW1vdGVUYWdzLmZvckVhY2goZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZi5uYW1lLmluZGV4T2YoJ157fScpICE9IC0xKSB7XG4gICAgICB2YXIgdGFnUmVmID0gcmVmLm5hbWUuc2xpY2UoMCwgcmVmLm5hbWUubGVuZ3RoIC0gJ157fScubGVuZ3RoKTtcbiAgICAgIHZhciBuYW1lID0gJ3JlbW90ZS10YWc6ICcgKyByZWYucmVtb3RlICsgJy8nICsgdGFnUmVmLnNwbGl0KCcvJylbMl07XG4gICAgICB2YXIgcmVmVmlld01vZGVsID0gc2VsZi5nZXRSZWYobmFtZSk7XG4gICAgICB2YXIgbm9kZSA9IHNlbGYuZ2V0Tm9kZShyZWYuc2hhMSk7XG4gICAgICByZWZWaWV3TW9kZWwubm9kZShub2RlKTtcblxuICAgICAgbm9kZUlkc1RvUmVtb3RlVGFnc1tyZWYuc2hhMV0gPSBub2RlSWRzVG9SZW1vdGVUYWdzW3JlZi5zaGExXSB8fCBbXTtcbiAgICAgIG5vZGVJZHNUb1JlbW90ZVRhZ3NbcmVmLnNoYTFdLnB1c2gocmVmVmlld01vZGVsKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvcih2YXIga2V5IGluIHRoaXMubm9kZXNCeUlkKVxuICAgIHRoaXMubm9kZXNCeUlkW2tleV0ucmVtb3RlVGFncyhub2RlSWRzVG9SZW1vdGVUYWdzW2tleV0gfHwgW10pO1xufVxuXG5HaXRHcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuc2V0Tm9kZXNGcm9tTG9nID0gZnVuY3Rpb24obm9kZXNEYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG5vZGVWTXMgPSBbXTtcbiAgbm9kZXNEYXRhLmZvckVhY2goZnVuY3Rpb24obm9kZURhdGEpIHtcbiAgICB2YXIgbm9kZVZpZXdNb2RlbCA9IHNlbGYuZ2V0Tm9kZShub2RlRGF0YS5zaGExKTtcbiAgICAvLyBPbmx5IHNldCB0aGUgZGF0YSBmb3IgdGhlIG5vZGUgb25jZSAoc2luY2Ugbm9kZXMgbmV2ZXIgY2hhbmdlKVxuICAgIGlmICghbm9kZVZpZXdNb2RlbC5pc0luaXRlZCkgbm9kZVZpZXdNb2RlbC5zZXREYXRhKG5vZGVEYXRhKTtcbiAgICBub2RlVk1zLnB1c2gobm9kZVZpZXdNb2RlbCk7XG4gICAgaWYgKG5vZGVEYXRhLnJlZnMpIHtcbiAgICAgIHZhciByZWZWTXMgPSBub2RlRGF0YS5yZWZzLm1hcChmdW5jdGlvbihyZWYpIHtcbiAgICAgICAgdmFyIHJlZlZpZXdNb2RlbCA9IHNlbGYuZ2V0UmVmKHJlZik7XG4gICAgICAgIHJlZlZpZXdNb2RlbC5ub2RlKG5vZGVWaWV3TW9kZWwpO1xuICAgICAgICByZXR1cm4gcmVmVmlld01vZGVsO1xuICAgICAgfSk7XG4gICAgICBub2RlVmlld01vZGVsLmJyYW5jaGVzQW5kTG9jYWxUYWdzKHJlZlZNcyk7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5zZXROb2Rlcyhub2RlVk1zKTtcbn1cbkdpdEdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24oc2hhMSkge1xuICB2YXIgbm9kZVZpZXdNb2RlbCA9IHRoaXMubm9kZXNCeUlkW3NoYTFdO1xuICBpZiAoIW5vZGVWaWV3TW9kZWwpIG5vZGVWaWV3TW9kZWwgPSB0aGlzLm5vZGVzQnlJZFtzaGExXSA9IG5ldyBHaXROb2RlVmlld01vZGVsKHRoaXMsIHNoYTEpO1xuICByZXR1cm4gbm9kZVZpZXdNb2RlbDtcbn1cbkdpdEdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5nZXRSZWYgPSBmdW5jdGlvbihmdWxsUmVmTmFtZSwgY29uc3RydWN0SWZVbmF2YWlsYWJsZSkge1xuICBpZiAoY29uc3RydWN0SWZVbmF2YWlsYWJsZSA9PT0gdW5kZWZpbmVkKSBjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgdmFyIHJlZlZpZXdNb2RlbCA9IHRoaXMucmVmc0J5UmVmTmFtZVtmdWxsUmVmTmFtZV07XG4gIGlmICghcmVmVmlld01vZGVsICYmIGNvbnN0cnVjdElmVW5hdmFpbGFibGUpIHtcbiAgICByZWZWaWV3TW9kZWwgPSB0aGlzLnJlZnNCeVJlZk5hbWVbZnVsbFJlZk5hbWVdID0gbmV3IFJlZlZpZXdNb2RlbCh7IG5hbWU6IGZ1bGxSZWZOYW1lLCBncmFwaDogdGhpcyB9KTtcbiAgICB0aGlzLnJlZnMucHVzaChyZWZWaWV3TW9kZWwpO1xuICB9XG4gIHJldHVybiByZWZWaWV3TW9kZWw7XG59XG5HaXRHcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uKG5vZGVBc2hhMSwgbm9kZUJzaGExKSB7XG4gIHZhciBpZCA9IG5vZGVBc2hhMSArICctJyArIG5vZGVCc2hhMTtcbiAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2VzQnlJZFtpZF07XG4gIGlmICghZWRnZSkge1xuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzQnlJZFtpZF0gPSBuZXcgRWRnZVZpZXdNb2RlbCh0aGlzLmdldE5vZGUobm9kZUFzaGExKSwgdGhpcy5nZXROb2RlKG5vZGVCc2hhMSkpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuXG5HaXRHcmFwaFZpZXdNb2RlbC5nZXRIRUFEID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgcmV0dXJuIF8uZmluZChub2RlcywgZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gXy5maW5kKG5vZGUucmVmcygpLCAnaXNMb2NhbEhFQUQnKTsgfSk7XG59XG5cbkdpdEdyYXBoVmlld01vZGVsLnRyYXZlcnNlTm9kZVBhcmVudHMgPSBmdW5jdGlvbihub2RlLCBub2Rlc0J5SWQsIGNhbGxiYWNrKSB7XG4gIGlmIChub2RlLmluZGV4KCkgPj0gdGhpcy5tYXhOTm9kZXMpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFjYWxsYmFjayhub2RlKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBpPTA7IGkgPCBub2RlLnBhcmVudHMoKS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJlbnQgPSBub2Rlc0J5SWRbbm9kZS5wYXJlbnRzKClbaV1dO1xuICAgIGlmIChwYXJlbnQpXG4gICAgICBHaXRHcmFwaFZpZXdNb2RlbC50cmF2ZXJzZU5vZGVQYXJlbnRzKHBhcmVudCwgbm9kZXNCeUlkLCBjYWxsYmFjayk7XG4gIH1cbn1cbkdpdEdyYXBoVmlld01vZGVsLnRyYXZlcnNlTm9kZUxlZnRQYXJlbnRzID0gZnVuY3Rpb24obm9kZSwgbm9kZXNCeUlkLCBjYWxsYmFjaykge1xuICBpZiAobm9kZS5pbmRleCgpID49IHRoaXMubWF4Tk5vZGVzKSByZXR1cm47XG4gIGNhbGxiYWNrKG5vZGUpO1xuICB2YXIgcGFyZW50ID0gbm9kZXNCeUlkW25vZGUucGFyZW50cygpWzBdXTtcbiAgaWYgKHBhcmVudClcbiAgICBHaXRHcmFwaFZpZXdNb2RlbC50cmF2ZXJzZU5vZGVMZWZ0UGFyZW50cyhwYXJlbnQsIG5vZGVzQnlJZCwgY2FsbGJhY2spO1xufVxuXG5HaXRHcmFwaFZpZXdNb2RlbC5fbWFya0lkZW9sb2dpY2FsU3RhbXAgPSAwO1xuR2l0R3JhcGhWaWV3TW9kZWwubWFya05vZGVzSWRlb2xvZ2ljYWxCcmFuY2hlcyA9IGZ1bmN0aW9uKHJlZnMsIG5vZGVzLCBub2Rlc0J5SWQpIHtcbiAgcmVmcyA9IHJlZnMuZmlsdGVyKGZ1bmN0aW9uKHIpIHsgcmV0dXJuICEhci5ub2RlKCk7IH0pO1xuICByZWZzID0gcmVmcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAoYS5pc0xvY2FsICYmICFiLmlzTG9jYWwpIHJldHVybiAtMTtcbiAgICBpZiAoYi5pc0xvY2FsICYmICFhLmlzTG9jYWwpIHJldHVybiAxO1xuICAgIGlmIChhLmlzQnJhbmNoICYmICFiLmlzQnJhbmNoKSByZXR1cm4gLTE7XG4gICAgaWYgKGIuaXNCcmFuY2ggJiYgIWEuaXNCcmFuY2gpIHJldHVybiAxO1xuICAgIGlmIChhLmlzSGVhZCAmJiAhYi5pc0hlYWQpIHJldHVybiAxO1xuICAgIGlmICghYS5pc0hlYWQgJiYgYi5pc0hlYWQpIHJldHVybiAtMTtcbiAgICBpZiAoYS5pc1N0YXNoICYmICFiLmlzU3Rhc2gpIHJldHVybiAxO1xuICAgIGlmIChiLmlzU3Rhc2ggJiYgIWEuaXNTdGFzaCkgcmV0dXJuIC0xO1xuICAgIGlmIChhLm5vZGUoKSAmJiBhLm5vZGUoKS5jb21taXRUaW1lKCkgJiYgYi5ub2RlKCkgJiYgYi5ub2RlKCkuY29tbWl0VGltZSgpKVxuICAgICAgcmV0dXJuIGEubm9kZSgpLmNvbW1pdFRpbWUoKSAtIGIubm9kZSgpLmNvbW1pdFRpbWUoKTtcbiAgICByZXR1cm4gYS5yZWZOYW1lIDwgYi5yZWZOYW1lID8gLTEgOiAxO1xuICB9KTtcbiAgdmFyIHN0YW1wID0gR2l0R3JhcGhWaWV3TW9kZWwuX21hcmtJZGVvbG9naWNhbFN0YW1wKys7XG4gIHJlZnMuZm9yRWFjaChmdW5jdGlvbihyZWYpIHtcbiAgICBHaXRHcmFwaFZpZXdNb2RlbC50cmF2ZXJzZU5vZGVQYXJlbnRzKHJlZi5ub2RlKCksIG5vZGVzQnlJZCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuc3RhbXAgPT0gc3RhbXApIHJldHVybiBmYWxzZTtcbiAgICAgIG5vZGUuc3RhbXAgPSBzdGFtcDtcbiAgICAgIG5vZGUuaWRlb2xvZ2ljYWxCcmFuY2gocmVmKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuR2l0R3JhcGhWaWV3TW9kZWwucmFuZG9tQ29sb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJhbmRvbUhleCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KS50b1N0cmluZygxNik7XG4gICAgaWYgKHIubGVuZ3RoID09IDEpIHIgPSAnMCcgKyByO1xuICAgIHJldHVybiByO1xuICB9XG4gIHJldHVybiAnIycgKyByYW5kb21IZXgoKSArIHJhbmRvbUhleCgpICsgcmFuZG9tSGV4KCk7XG59XG5cblxuR2l0R3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnNldE5vZGVzID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlLCBpKSB7IG5vZGUuaW5kZXgoaSk7IH0pO1xuICBub2RlcyA9IG5vZGVzLnNsaWNlKDAsIEdpdEdyYXBoVmlld01vZGVsLm1heE5Ob2Rlcyk7XG5cbiAgR2l0R3JhcGhWaWV3TW9kZWwubWFya05vZGVzSWRlb2xvZ2ljYWxCcmFuY2hlcyh0aGlzLnJlZnMoKSwgbm9kZXMsIHRoaXMubm9kZXNCeUlkKTtcbiAgdGhpcy5IRUFEKEdpdEdyYXBoVmlld01vZGVsLmdldEhFQUQobm9kZXMpKTtcbiAgdmFyIEhFQUQgPSB0aGlzLkhFQUQoKTtcblxuICB2YXIgdXBkYXRlVGltZVN0YW1wID0gbW9tZW50KCkudmFsdWVPZigpO1xuXG4gIC8vIE1hcmsgdGltZXN0YW1wc1xuICBpZiAoSEVBRCkge1xuICAgIEdpdEdyYXBoVmlld01vZGVsLnRyYXZlcnNlTm9kZUxlZnRQYXJlbnRzKEhFQUQsIHRoaXMubm9kZXNCeUlkLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID0gdXBkYXRlVGltZVN0YW1wO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRmlsdGVyIG91dCBub2RlcyB3aGljaCBkb2Vzbid0IGhhdmUgYSBicmFuY2ggKHN0YWdpbmcgYW5kIG9ycGhhbmVkIG5vZGVzKVxuICBub2RlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbihub2RlKSB7IHJldHVybiAobm9kZS5pZGVvbG9naWNhbEJyYW5jaCgpICYmICFub2RlLmlkZW9sb2dpY2FsQnJhbmNoKCkuaXNTdGFzaCkgfHwgbm9kZS5hbmNlc3Rvck9mSEVBRFRpbWVTdGFtcCA9PSB1cGRhdGVUaW1lU3RhbXA7IH0pXG5cbiAgLy92YXIgY29uY3VycmVudEJyYW5jaGVzID0geyB9O1xuXG4gIHZhciBicmFuY2hTbG90cyA9IFtdO1xuXG4gIC8vIFRoZW4gaXRlcmF0ZSBmcm9tIHRoZSBib3R0b20gdG8gZml4IHRoZSBvcmRlcnMgb2YgdGhlIGJyYW5jaGVzXG4gIGZvciAodmFyIGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPT0gdXBkYXRlVGltZVN0YW1wKSBjb250aW51ZTtcbiAgICB2YXIgaWRlb2xvZ2ljYWxCcmFuY2ggPSBub2RlLmlkZW9sb2dpY2FsQnJhbmNoKCk7XG5cbiAgICAvLyBGaXJzdCBvY2N1cmVuY2Ugb2YgdGhlIGJyYW5jaCwgZmluZCBhbiBlbXB0eSBzbG90IGZvciB0aGUgYnJhbmNoXG4gICAgaWYgKGlkZW9sb2dpY2FsQnJhbmNoLmxhc3RTbG90dGVkVGltZVN0YW1wICE9IHVwZGF0ZVRpbWVTdGFtcCkge1xuICAgICAgaWRlb2xvZ2ljYWxCcmFuY2gubGFzdFNsb3R0ZWRUaW1lU3RhbXAgPSB1cGRhdGVUaW1lU3RhbXA7XG4gICAgICB2YXIgc2xvdCA9IDA7XG4gICAgICBmb3IoO3Nsb3QgPCBicmFuY2hTbG90cy5sZW5ndGg7IHNsb3QrKylcbiAgICAgICAgaWYgKGJyYW5jaFNsb3RzW3Nsb3RdID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgaWYgKHNsb3QgPT0gYnJhbmNoU2xvdHMubGVuZ3RoKSB7XG4gICAgICAgIGJyYW5jaFNsb3RzLnB1c2goaWRlb2xvZ2ljYWxCcmFuY2gpO1xuICAgICAgICBzbG90ID0gYnJhbmNoU2xvdHMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGlkZW9sb2dpY2FsQnJhbmNoLmJyYW5jaE9yZGVyID0gc2xvdDtcbiAgICAgIGJyYW5jaFNsb3RzW3Nsb3RdID0gc2xvdDtcbiAgICB9XG5cbiAgICBub2RlLmJyYW5jaE9yZGVyID0gaWRlb2xvZ2ljYWxCcmFuY2guYnJhbmNoT3JkZXI7XG5cbiAgICAvLyBGcmVlIGJyYW5jaCBzbG90cyB3aGVuIHdlIHJlYWNoIHRoZSBlbmQgb2YgYSBicmFuY2hcbiAgICAvKmlmIChub2RlID09IGlkZW9sb2dpY2FsQnJhbmNoLm5vZGUoKSkge1xuICAgICAgYnJhbmNoU2xvdHNbaWRlb2xvZ2ljYWxCcmFuY2guYnJhbmNoT3JkZXJdID0gdW5kZWZpbmVkO1xuICAgIH0qL1xuICB9XG5cbiAgdmFyIHByZXZOb2RlO1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmJyYW5jaE9yZGVyID0gYnJhbmNoU2xvdHMubGVuZ3RoIC0gbm9kZS5icmFuY2hPcmRlcjtcbiAgICBub2RlLmFuY2VzdG9yT2ZIRUFEKG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPT0gdXBkYXRlVGltZVN0YW1wKTtcbiAgICBub2RlLmFib3ZlTm9kZSA9IHByZXZOb2RlO1xuICAgIGlmIChwcmV2Tm9kZSkgcHJldk5vZGUuYmVsb3dOb2RlID0gbm9kZTtcbiAgICBub2RlLnVwZGF0ZUdvYWxQb3NpdGlvbigpO1xuICAgIHByZXZOb2RlID0gbm9kZTtcbiAgfSk7XG5cbiAgdGhpcy5ub2Rlcyhub2Rlcyk7XG59XG5cbkdpdEdyYXBoVmlld01vZGVsLnByb3RvdHlwZS5pbnN0YW50VXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLnVwZGF0ZUdvYWxQb3NpdGlvbigpO1xuICAgIG5vZGUucG9zaXRpb24obm9kZS5nb2FsUG9zaXRpb24oKSk7XG4gIH0pO1xufVxuXG5HaXRHcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuaGFuZGxlQnViYmxlZENsaWNrID0gZnVuY3Rpb24oZWxlbSwgZXZlbnQpIHtcbiAgLy8gSWYgdGhlIGNsaWNrZWQgZWxlbWVudCBpcyBib3VuZCB0byB0aGUgY3VycmVudCBhY3Rpb24gY29udGV4dCxcbiAgLy8gdGhlbiBsZXQncyBub3QgZGVzZWxlY3QgaXQuXG4gIGlmIChrby5kYXRhRm9yKGV2ZW50LnRhcmdldCkgPT09IHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQoKSkgcmV0dXJuO1xuICBpZiAodGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpICYmIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIEdpdE5vZGVWaWV3TW9kZWwpIHtcbiAgICB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkudG9nZ2xlU2VsZWN0ZWQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KG51bGwpO1xuICB9XG4gIC8vIElmIHRoZSBjbGljayB3YXMgb24gYW4gaW5wdXQgZWxlbWVudCwgdGhlbiBsZXQncyBhbGxvdyB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gcHJvY2VlZC5cbiAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IG5lZWRlZCBzaW5jZSBmb3Igc29tZSBzdHJhbmdlIHJlYXNvbiBhbnkgc3VibWl0IChpZS4gZW50ZXIgaW4gYSB0ZXh0Ym94KVxuICAvLyB3aWxsIHRyaWdnZXIgYSBjbGljayBldmVudCBvbiB0aGUgc3VibWl0IGlucHV0IG9mIHRoZSBmb3JtLCB3aGljaCB3aWxsIGVuZCB1cCBoZXJlLFxuICAvLyBhbmQgaWYgd2UgZG9uJ3QgcmV0dXJuIHRydWUsIHRoZW4gdGhlIHN1Ym1pdCBldmVudCBpcyBuZXZlciBmaXJlZCwgYnJlYWtpbmcgc3R1ZmYuXG4gIGlmIChldmVudC50YXJnZXQubm9kZU5hbWUgPT09ICdJTlBVVCcpIHJldHVybiB0cnVlO1xufVxuIiwiXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG52YXIgUmVmVmlld01vZGVsID0gcmVxdWlyZSgnLi9yZWYuanMnKS5SZWZWaWV3TW9kZWw7XG52YXIgZ3JhcGhHcmFwaGljc0FjdGlvbnMgPSByZXF1aXJlKCcuL2dyYXBoLWdyYXBoaWNzL2FjdGlvbnMnKTtcbnZhciBSZWJhc2VWaWV3TW9kZWwgPSBncmFwaEdyYXBoaWNzQWN0aW9ucy5SZWJhc2VWaWV3TW9kZWw7XG52YXIgTWVyZ2VWaWV3TW9kZWwgPSBncmFwaEdyYXBoaWNzQWN0aW9ucy5NZXJnZVZpZXdNb2RlbDtcbnZhciBSZXNldFZpZXdNb2RlbCA9IGdyYXBoR3JhcGhpY3NBY3Rpb25zLlJlc2V0Vmlld01vZGVsO1xudmFyIFB1c2hWaWV3TW9kZWwgPSBncmFwaEdyYXBoaWNzQWN0aW9ucy5QdXNoVmlld01vZGVsO1xudmFyIHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xuXG52YXIgR3JhcGhBY3Rpb25zID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoQWN0aW9ucztcblxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UgPSBmdW5jdGlvbihncmFwaCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5zZXJ2ZXIgPSBncmFwaC5zZXJ2ZXI7XG4gIHRoaXMucGVyZm9ybVByb2dyZXNzQmFyID0gY29tcG9uZW50cy5jcmVhdGUoJ3Byb2dyZXNzQmFyJywge1xuICAgIHByZWRpY3Rpb25NZW1vcnlLZXk6ICdhY3Rpb24tJyArIHRoaXMuc3R5bGUgKyAnLScgKyBncmFwaC5yZXBvUGF0aCxcbiAgICBmYWxsYmFja1ByZWRpY3RlZFRpbWVNczogMTAwMCxcbiAgICB0ZW1wb3Jhcnk6IHRydWVcbiAgfSk7XG5cbiAgdGhpcy5pc0hpZ2hsaWdodGVkID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICFncmFwaC5ob3ZlckdyYXBoQWN0aW9uKCkgfHwgZ3JhcGguaG92ZXJHcmFwaEFjdGlvbigpID09IHNlbGY7XG4gIH0pO1xuICB0aGlzLmNzc0NsYXNzZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgYyA9IHNlbGYuc3R5bGU7XG4gICAgaWYgKCFzZWxmLmlzSGlnaGxpZ2h0ZWQoKSkgYyArPSAnIGRpbW1lZCc7XG4gICAgcmV0dXJuIGM7XG4gIH0pXG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuaWNvbiA9IG51bGw7XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuZG9QZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xuICBzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5zdGFydCgpO1xuICB0aGlzLnBlcmZvcm0oZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIuc3RvcCgpO1xuICB9KTtcbn1cbkdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLnByb3RvdHlwZS5kcmFnRW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnZpc2libGUoKSkgcmV0dXJuO1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24odGhpcyk7XG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuZHJhZ0xlYXZlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy52aXNpYmxlKCkpIHJldHVybjtcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xufVxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLm1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24odGhpcyk7XG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUubW91c2VvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xufVxuXG5HcmFwaEFjdGlvbnMuTW92ZSA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgIT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5Nb3ZlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuTW92ZS5wcm90b3R5cGUudGV4dCA9ICdNb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5zdHlsZSA9ICdtb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5pY29uID0gJ2dseXBoaWNvbi1tb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm1vdmVUbyh0aGlzLm5vZGUuc2hhMSwgY2FsbGJhY2spO1xufVxuXG5cbkdyYXBoQWN0aW9ucy5SZXNldCA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMub250byA9IGtvLm9ic2VydmFibGUodGhpcy5ub2RlKTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCEoc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBjb250ZXh0ID0gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIGlmIChjb250ZXh0Lm5vZGUoKSAhPSBzZWxmLm5vZGUpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYoc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICAgIHJldHVybiByZW1vdGVSZWYgJiZcbiAgICAgIHJlbW90ZVJlZi5ub2RlKCkgIT0gY29udGV4dC5ub2RlKCkgJiZcbiAgICAgIHJlbW90ZVJlZi5ub2RlKCkuY29tbWl0VGltZSgpIDwgY29udGV4dC5ub2RlKCkuY29tbWl0VGltZSgpO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5SZXNldCwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLlJlc2V0LnByb3RvdHlwZS50ZXh0ID0gJ1Jlc2V0JztcbkdyYXBoQWN0aW9ucy5SZXNldC5wcm90b3R5cGUuc3R5bGUgPSAncmVzZXQnO1xuR3JhcGhBY3Rpb25zLlJlc2V0LnByb3RvdHlwZS5pY29uID0gJ2dseXBoaWNvbi10cmFzaCc7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgdmFyIHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgdmFyIG5vZGVzID0gY29udGV4dC5ub2RlKCkuZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IocmVtb3RlUmVmLm5vZGUoKSkuc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gbmV3IFJlc2V0Vmlld01vZGVsKG5vZGVzKTtcbn1cbkdyYXBoQWN0aW9ucy5SZXNldC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZXJ2ZXIgPSB0aGlzLnNlcnZlcjtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIHZhciByZW1vdGUgPSB0aGlzLmdyYXBoLmN1cnJlbnRSZW1vdGUoKTtcbiAgdmFyIHJlcG9QYXRoID0gdGhpcy5ncmFwaC5yZXBvUGF0aDtcbiAgdmFyIGRpYWcgPSBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnQXJlIHlvdSBzdXJlPycsIGRldGFpbHM6ICdUaGlzIG9wZXJhdGlvbiBjYW5ub3QgYmUgdW5kb25lIHdpdGggdW5naXQuJ30pO1xuICBkaWFnLmNsb3NlZC5hZGQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcblx0XHR2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYocmVtb3RlKTtcbiAgICAgICAgc2VydmVyLnBvc3QoJy9yZXNldCcsIHsgcGF0aDogcmVwb1BhdGgsIHRvOiByZW1vdGVSZWYubmFtZSwgbW9kZTogJ2hhcmQnIH0sIGNhbGxiYWNrKTtcblx0fSBlbHNlIHtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG4gIH0pO1xuICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LXNob3ctZGlhbG9nJywgZGlhbG9nOiBkaWFnIH0pO1xufVxuXG5HcmFwaEFjdGlvbnMuUmViYXNlID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgKCF1bmdpdC5jb25maWcuc2hvd1JlYmFzZUFuZE1lcmdlT25seU9uUmVmcyB8fCBzZWxmLm5vZGUucmVmcygpLmxlbmd0aCA+IDApICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpICE9IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuUmViYXNlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS50ZXh0ID0gJ1JlYmFzZSc7XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS5zdHlsZSA9ICdyZWJhc2UnO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvbnRvID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIW9udG8pIHJldHVybjtcbiAgaWYgKG9udG8gaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG9udG8gPSBvbnRvLm5vZGUoKTtcbiAgdmFyIHBhdGggPSBvbnRvLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKHRoaXMubm9kZSk7XG4gIHJldHVybiBuZXcgUmViYXNlVmlld01vZGVsKHRoaXMubm9kZSwgcGF0aCk7XG59XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL3JlYmFzZScsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgb250bzogdGhpcy5ub2RlLnNoYTEgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICBpZiAoZXJyICYmIGVyci5lcnJvckNvZGUgPT0gJ21lcmdlLWZhaWxlZCcpIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuXG5HcmFwaEFjdGlvbnMuTWVyZ2UgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLm1lcmdlV2l0aCA9IGtvLm9ic2VydmFibGUodGhpcy5ub2RlKTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFzZWxmLmdyYXBoLmNoZWNrZWRPdXRSZWYoKSB8fCAhc2VsZi5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgIXNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5jdXJyZW50KCkgJiZcbiAgICAgIHNlbGYuZ3JhcGguY2hlY2tlZE91dFJlZigpLm5vZGUoKSA9PSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLk1lcmdlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLnRleHQgPSAnTWVyZ2UnO1xuR3JhcGhBY3Rpb25zLk1lcmdlLnByb3RvdHlwZS5zdHlsZSA9ICdtZXJnZSc7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG5vZGUgPSBub2RlLm5vZGUoKTtcbiAgcmV0dXJuIG5ldyBNZXJnZVZpZXdNb2RlbCh0aGlzLmdyYXBoLmdyYXBoaWMsIHRoaXMubm9kZSwgbm9kZSk7XG59XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLnNlcnZlci5wb3N0KCcvbWVyZ2UnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIHdpdGg6IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5sb2NhbFJlZk5hbWUgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICBpZiAoZXJyICYmIGVyci5lcnJvckNvZGUgPT0gJ21lcmdlLWZhaWxlZCcpIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlB1c2ggPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpID09IHNlbGYubm9kZSAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmNhbkJlUHVzaGVkKHNlbGYuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuUHVzaCwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLnRleHQgPSAnUHVzaCc7XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUuc3R5bGUgPSAncHVzaCc7XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUuaWNvbiA9ICdnbHlwaGljb24tb3Blbic7XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIWNvbnRleHQpIHJldHVybiBudWxsO1xuICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYodGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICBpZiAoIXJlbW90ZVJlZikgcmV0dXJuIG51bGw7XG4gIHJldHVybiBuZXcgUHVzaFZpZXdNb2RlbChyZW1vdGVSZWYubm9kZSgpLCBjb250ZXh0Lm5vZGUoKSk7XG59XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9ncmFtRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmV2ZW50ID09ICdyZXF1ZXN0LWNyZWRlbnRpYWxzJykgc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucGF1c2UoKTtcbiAgICBlbHNlIGlmIChldmVudC5ldmVudCA9PSAncmVxdWVzdC1jcmVkZW50aWFscy1yZXNwb25zZScpIHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnVucGF1c2UoKTtcbiAgfTtcbiAgcHJvZ3JhbUV2ZW50cy5hZGQocHJvZ3JhbUV2ZW50TGlzdGVuZXIpO1xuICB2YXIgcmVmID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICB2YXIgb25Eb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgcHJvZ3JhbUV2ZW50cy5yZW1vdmUocHJvZ3JhbUV2ZW50TGlzdGVuZXIpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIHNlbGYuZ3JhcGgubG9hZE5vZGVzRnJvbUFwaSgpO1xuICAgICAgaWYgKHJlZi5pc1RhZykge1xuICAgICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LWZldGNoLXRhZ3MnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVtb3RlUmVmID0gcmVmLmdldFJlbW90ZVJlZih0aGlzLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSk7XG4gIGlmIChyZW1vdGVSZWYpIHJlbW90ZVJlZi5tb3ZlVG8ocmVmLnJlZk5hbWUsIG9uRG9uZSk7XG4gIGVsc2UgcmVmLmNyZWF0ZVJlbW90ZVJlZihvbkRvbmUpO1xufVxuXG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKVxuICAgICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgPT0gc2VsZi5ub2RlICYmXG4gICAgICAgICFzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpO1xuICAgIHJldHVybiB1bmdpdC5jb25maWcuYWxsb3dDaGVja291dE5vZGVzICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgPT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5DaGVja291dCwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLkNoZWNrb3V0LnByb3RvdHlwZS50ZXh0ID0gJ0NoZWNrb3V0JztcbkdyYXBoQWN0aW9ucy5DaGVja291dC5wcm90b3R5cGUuc3R5bGUgPSAnY2hlY2tvdXQnO1xuR3JhcGhBY3Rpb25zLkNoZWNrb3V0LnByb3RvdHlwZS5pY29uID0gJ2dseXBoaWNvbi1mb2xkZXItb3Blbic7XG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICB2YXIgcmVmTmFtZTtcbiAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIHJlZk5hbWUgPSBjb250ZXh0LnJlZk5hbWU7XG4gIGVsc2UgcmVmTmFtZSA9IGNvbnRleHQuc2hhMTtcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL2NoZWNrb3V0JywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCBuYW1lOiByZWZOYW1lIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiYgY29udGV4dC5pc1JlbW90ZUJyYW5jaClcbiAgICAgIHNlbGYuc2VydmVyLnBvc3QoJy9yZXNldCcsIHsgcGF0aDogc2VsZi5ncmFwaC5yZXBvUGF0aCwgdG86IGNvbnRleHQubmFtZSwgbW9kZTogJ2hhcmQnIH0sIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJykgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG5HcmFwaEFjdGlvbnMuRGVsZXRlID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSA9PSBzZWxmLm5vZGUgJiZcbiAgICAgICFzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY3VycmVudCgpO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5EZWxldGUsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5EZWxldGUucHJvdG90eXBlLnRleHQgPSAnRGVsZXRlJztcbkdyYXBoQWN0aW9ucy5EZWxldGUucHJvdG90eXBlLnN0eWxlID0gJ2RlbGV0ZSc7XG5HcmFwaEFjdGlvbnMuRGVsZXRlLnByb3RvdHlwZS5pY29uID0gJ2dseXBoaWNvbi1yZW1vdmUnO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICB2YXIgZGlhZyA9IGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub2RpYWxvZycsIHsgdGl0bGU6ICdBcmUgeW91IHN1cmU/JywgZGV0YWlsczogJ1RoaXMgb3BlcmF0aW9uIGNhbm5vdCBiZSB1bmRvbmUgd2l0aCB1bmdpdC4nfSk7XG4gIGRpYWcuY2xvc2VkLmFkZChmdW5jdGlvbigpIHtcbiAgICBpZiAoZGlhZy5yZXN1bHQoKSkge1xuXHRcdGNvbnRleHQucmVtb3ZlKGNhbGxiYWNrKTtcblx0fSBlbHNlIHtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG4gIH0pO1xuICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LXNob3ctZGlhbG9nJywgZGlhbG9nOiBkaWFnIH0pO1xufVxuXG5cbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSBzZWxmLm5vZGVcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuQ2hlcnJ5UGljaywgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2sucHJvdG90eXBlLnRleHQgPSAnQ2hlcnJ5IHBpY2snO1xuR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2sucHJvdG90eXBlLnN0eWxlID0gJ2NoZXJyeS1waWNrJztcbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlcnZlci5wb3N0KCcvY2hlcnJ5cGljaycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgbmFtZTogdGhpcy5ub2RlLnNoYTEgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICBpZiAoZXJyICYmIGVyci5lcnJvckNvZGUgPT0gJ21lcmdlLWZhaWxlZCcpIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlVuY29tbWl0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSBzZWxmLm5vZGUgJiZcbiAgICAgIHNlbGYuZ3JhcGguSEVBRCgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuVW5jb21taXQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUudGV4dCA9ICdVbmNvbW1pdCc7XG5HcmFwaEFjdGlvbnMuVW5jb21taXQucHJvdG90eXBlLnN0eWxlID0gJ3VuY29tbWl0JztcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL3Jlc2V0JywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCB0bzogJ0hFQUReJywgbW9kZTogJ21peGVkJyB9LCBjYWxsYmFjayk7XG59XG5cbkdyYXBoQWN0aW9ucy5SZXZlcnQgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuUmV2ZXJ0LCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUmV2ZXJ0LnByb3RvdHlwZS50ZXh0ID0gJ1JldmVydCc7XG5HcmFwaEFjdGlvbnMuUmV2ZXJ0LnByb3RvdHlwZS5zdHlsZSA9ICdyZXZlcnQnO1xuR3JhcGhBY3Rpb25zLlJldmVydC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL3JldmVydCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgY29tbWl0OiB0aGlzLm5vZGUuc2hhMSB9LCBjYWxsYmFjayk7XG59XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIFNlbGVjdGFibGUgPSByZXF1aXJlKCcuL2dpdC1zZWxlY3RhYmxlJykuU2VsZWN0YWJsZTtcbnZhciBHcmFwaEFjdGlvbnMgPSByZXF1aXJlKCcuL2dpdC1ncmFwaC1hY3Rpb25zJyk7XG52YXIgTm9kZVZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZ3JhcGgtZ3JhcGhpY3Mvbm9kZScpLk5vZGVWaWV3TW9kZWw7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBWZWN0b3IyID0gcmVxdWlyZSgndW5naXQtdmVjdG9yMicpO1xuXG52YXIgR2l0Tm9kZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKGdyYXBoLCBzaGExKSB7XG4gIE5vZGVWaWV3TW9kZWwuY2FsbCh0aGlzKTtcbiAgU2VsZWN0YWJsZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5zZXJ2ZXIgPSBncmFwaC5zZXJ2ZXI7XG4gIHRoaXMuc2hhMSA9IHNoYTE7XG5cbiAgdGhpcy5pc0luaXRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYm94RGlzcGxheVggPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi54KCk7XG4gIH0pO1xuICB0aGlzLmJveERpc3BsYXlZID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYueSgpO1xuICB9KTtcbiAgdGhpcy5jb21taXRDb250YWluZXJYID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC1zZWxmLnJhZGl1cygpO1xuICB9KVxuICB0aGlzLnJlZnNYID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYucmFkaXVzKCk7XG4gIH0pO1xuICB0aGlzLm5vZGVYID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC1zZWxmLnJhZGl1cygpO1xuICB9KTtcbiAgdGhpcy5ub2RlWSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAtc2VsZi5yYWRpdXMoKTtcbiAgfSk7XG4gIHRoaXMubm9kZVdpZHRoID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYucmFkaXVzKCkqMjtcbiAgfSk7XG4gIHRoaXMubm9kZUhlaWdodCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLnJhZGl1cygpKjI7XG4gIH0pO1xuICB0aGlzLmFib3ZlTm9kZSA9IG51bGw7IC8vIFRoZSBub2RlIGRpcmVjdGx5IGFib3ZlIHRoaXMsIGdyYXBoaWNhbGx5XG5cbiAgdGhpcy5wYXJlbnRzID0ga28ub2JzZXJ2YWJsZShbXSk7XG4gIHRoaXMudGl0bGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY29tbWl0VGltZSA9IGtvLm9ic2VydmFibGUoKTtcblxuICB0aGlzLmNvbW1pdENvbXBvbmVudCA9IGNvbXBvbmVudHMuY3JlYXRlKCdjb21taXQnLCB7XG4gICAgc2hhMTogc2hhMSxcbiAgICByZXBvUGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCxcbiAgICBzZXJ2ZXI6IGdyYXBoLnNlcnZlclxuICB9KTtcblxuICB0aGlzLmJveERpc3BsYXlYLnN1YnNjcmliZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIHNlbGYuY29tbWl0Q29tcG9uZW50LnNlbGVjdGVkRGlmZkxlZnRQb3NpdGlvbigtdmFsdWUpO1xuICB9KTtcblxuICB0aGlzLmluZGV4ID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmlkZW9sb2dpY2FsQnJhbmNoID0ga28ub2JzZXJ2YWJsZSgpO1xuICBzZWxmLmlkZW9sb2dpY2FsQnJhbmNoLnN1YnNjcmliZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIHNlbGYuY29sb3IodmFsdWUgPyB2YWx1ZS5jb2xvciA6ICcjNjY2Jyk7XG4gIH0pO1xuICB0aGlzLmFuY2VzdG9yT2ZIRUFEID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMubm9kZUlzTW91c2Vob3ZlciA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLm5vZGVJc01vdXNlaG92ZXIuc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgc2VsZi5jb21taXRDb21wb25lbnQubm9kZUlzTW91c2Vob3Zlcih2YWx1ZSk7XG4gIH0pO1xuICB0aGlzLmNvbW1pdENvbnRhaW5lclZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHNlbGYuYW5jZXN0b3JPZkhFQUQoKSAmJiBzZWxmLmlzQXRGaW5hbFhQb3NpdGlvbigpKSB8fCBzZWxmLm5vZGVJc01vdXNlaG92ZXIoKSB8fCBzZWxmLnNlbGVjdGVkKCk7XG4gIH0pO1xuICB0aGlzLmhpZ2hsaWdodGVkID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYubm9kZUlzTW91c2Vob3ZlcigpIHx8IHNlbGYuc2VsZWN0ZWQoKTtcbiAgfSk7XG4gIHRoaXMuaGlnaGxpZ2h0ZWQuc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgc2VsZi5jb21taXRDb21wb25lbnQuaGlnaGxpZ2h0ZWQodmFsdWUpO1xuICB9KTtcbiAgdGhpcy5zZWxlY3RlZC5zdWJzY3JpYmUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICBzZWxmLmNvbW1pdENvbXBvbmVudC5zZWxlY3RlZCh2YWx1ZSk7XG4gIH0pO1xuICAvLyBUaGVzZSBhcmUgc3BsaXQgdXAgbGlrZSB0aGlzIGJlY2F1c2UgYnJhbmNoZXMgYW5kIGxvY2FsIHRhZ3MgY2FuIGJlIGZvdW5kIGluIHRoZSBnaXQgbG9nLFxuICAvLyB3aGVyZWFzIHJlbW90ZSB0YWdzIG5lZWRzIHRvIGJlIGZldGNoZWQgd2l0aCBhbm90aGVyIGNvbW1hbmQgKHdoaWNoIGlzIG11Y2ggc2xvd2VyKVxuICB0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzID0ga28ub2JzZXJ2YWJsZShbXSk7XG4gIHRoaXMucmVtb3RlVGFncyA9IGtvLm9ic2VydmFibGUoW10pO1xuICB0aGlzLnJlZnMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgcnMgPSBzZWxmLmJyYW5jaGVzQW5kTG9jYWxUYWdzKCkuY29uY2F0KHNlbGYucmVtb3RlVGFncygpKTtcbiAgICBycy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLmlzTG9jYWwgJiYgIWIuaXNMb2NhbCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKCFhLmlzTG9jYWwgJiYgYi5pc0xvY2FsKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiBhLnJlZk5hbWUgPCBiLnJlZk5hbWUgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzO1xuICB9KTtcbiAgdGhpcy5icmFuY2hlcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLnJlZnMoKS5maWx0ZXIoZnVuY3Rpb24ocikgeyByZXR1cm4gci5pc0JyYW5jaDsgfSk7XG4gIH0pO1xuICB0aGlzLnRhZ3MgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5yZWZzKCkuZmlsdGVyKGZ1bmN0aW9uKHIpIHsgcmV0dXJuIHIuaXNUYWc7IH0pO1xuICB9KTtcbiAgdGhpcy5zaG93TmV3UmVmQWN0aW9uID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICFncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICB9KVxuICB0aGlzLm5ld0JyYW5jaE5hbWUgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZUhhc0ZvY3VzID0ga28ub2JzZXJ2YWJsZSh0cnVlKTtcbiAgdGhpcy5uZXdCcmFuY2hOYW1lSGFzRm9jdXMuc3Vic2NyaWJlKGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgaWYgKCFuZXdWYWx1ZSkge1xuICAgICAgLy8gU21hbGwgdGltZW91dCBiZWNhdXNlIGluIGZmIHRoZSBmb3JtIGlzIGhpZGRlbiBiZWZvcmUgdGhlIHN1Ym1pdCBjbGljayBldmVudCBpcyByZWdpc3RlcmVkIG90aGVyd2lzZVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICB9LCAyMDApO1xuICAgIH1cbiAgfSlcbiAgdGhpcy5icmFuY2hpbmdGb3JtVmlzaWJsZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNhbkNyZWF0ZVJlZiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLm5ld0JyYW5jaE5hbWUoKSAmJiBzZWxmLm5ld0JyYW5jaE5hbWUoKS50cmltKCkgJiYgc2VsZi5uZXdCcmFuY2hOYW1lKCkuaW5kZXhPZignICcpID09IC0xO1xuICB9KTtcblxuICB0aGlzLmRyb3BhcmVhR3JhcGhBY3Rpb25zID0gW1xuICAgIG5ldyBHcmFwaEFjdGlvbnMuTW92ZSh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlJlYmFzZSh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLk1lcmdlKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuUHVzaCh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlJlc2V0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuQ2hlY2tvdXQodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5EZWxldGUodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5DaGVycnlQaWNrKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuVW5jb21taXQodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5SZXZlcnQodGhpcy5ncmFwaCwgdGhpcylcbiAgXTtcbn1cbmluaGVyaXRzKEdpdE5vZGVWaWV3TW9kZWwsIE5vZGVWaWV3TW9kZWwpO1xuZXhwb3J0cy5HaXROb2RlVmlld01vZGVsID0gR2l0Tm9kZVZpZXdNb2RlbDtcbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5wYXJlbnRzKGFyZ3MucGFyZW50cyB8fCBbXSk7XG4gIHRoaXMuY29tbWl0VGltZShhcmdzLmNvbW1pdERhdGUpO1xuICB0aGlzLnRpdGxlKGFyZ3MubWVzc2FnZS5zcGxpdCgnXFxuJylbMF0pO1xuICB0aGlzLmNvbW1pdENvbXBvbmVudC5zZXREYXRhKGFyZ3MpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihkZWx0YVQpIHtcbiAgdGhpcy5jb21taXRDb21wb25lbnQudXBkYXRlQW5pbWF0aW9uRnJhbWUoZGVsdGFUKTtcbiAgR2l0Tm9kZVZpZXdNb2RlbC5zdXBlcl8ucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbkZyYW1lLmNhbGwodGhpcywgZGVsdGFUKTtcblxuICB0aGlzLnVwZGF0ZUdvYWxQb3NpdGlvbigpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlR29hbFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnb2FsUG9zaXRpb24gPSBuZXcgVmVjdG9yMigpO1xuICBpZiAodGhpcy5hbmNlc3Rvck9mSEVBRCgpKSB7XG4gICAgaWYgKCF0aGlzLmFib3ZlTm9kZSlcbiAgICAgIGdvYWxQb3NpdGlvbi55ID0gMTIwO1xuICAgIGVsc2UgaWYgKHRoaXMuYWJvdmVOb2RlLmFuY2VzdG9yT2ZIRUFEKCkpXG4gICAgICBnb2FsUG9zaXRpb24ueSA9IHRoaXMuYWJvdmVOb2RlLmdvYWxQb3NpdGlvbigpLnkgKyAxMjA7XG4gICAgZWxzZVxuICAgICAgZ29hbFBvc2l0aW9uLnkgPSB0aGlzLmFib3ZlTm9kZS5nb2FsUG9zaXRpb24oKS55ICsgNjA7XG4gICAgZ29hbFBvc2l0aW9uLnggPSAzMDtcbiAgICB0aGlzLnNldFJhZGl1cygzMCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuYWJvdmVOb2RlKSB7XG4gICAgICBnb2FsUG9zaXRpb24ueSA9IHRoaXMuYWJvdmVOb2RlLmdvYWxQb3NpdGlvbigpLnkgKyA2MDtcbiAgICB9IGVsc2Uge1xuICAgICAgZ29hbFBvc2l0aW9uLnkgPSAxMjA7XG4gICAgfVxuXG4gICAgZ29hbFBvc2l0aW9uLnggPSAzMCArIDkwICogdGhpcy5icmFuY2hPcmRlcjtcbiAgICB0aGlzLnNldFJhZGl1cygxNSk7XG4gIH1cbiAgaWYgKHRoaXMuYWJvdmVOb2RlICYmIHRoaXMuYWJvdmVOb2RlLnNlbGVjdGVkKCkpIHtcbiAgICBnb2FsUG9zaXRpb24ueSA9IHRoaXMuYWJvdmVOb2RlLmdvYWxQb3NpdGlvbigpLnkgKyB0aGlzLmFib3ZlTm9kZS5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLm9mZnNldEhlaWdodCArIDMwO1xuICB9XG4gIHRoaXMuc2V0UG9zaXRpb24oZ29hbFBvc2l0aW9uKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNob3dCcmFuY2hpbmdGb3JtID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYnJhbmNoaW5nRm9ybVZpc2libGUodHJ1ZSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZUhhc0ZvY3VzKHRydWUpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICB0aGlzLnNlcnZlci5wb3N0KCcvYnJhbmNoZXMnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIG5hbWU6IHRoaXMubmV3QnJhbmNoTmFtZSgpLCBzdGFydFBvaW50OiB0aGlzLnNoYTEgfSk7XG4gIHRoaXMuYnJhbmNoaW5nRm9ybVZpc2libGUoZmFsc2UpO1xuICB0aGlzLm5ld0JyYW5jaE5hbWUoJycpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlVGFnID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICB0aGlzLnNlcnZlci5wb3N0KCcvdGFncycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgbmFtZTogdGhpcy5uZXdCcmFuY2hOYW1lKCksIHN0YXJ0UG9pbnQ6IHRoaXMuc2hhMSB9KTtcbiAgdGhpcy5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZSgnJyk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5pc0FuY2VzdG9yID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAodGhpcy5pbmRleCgpID49IHRoaXMuZ3JhcGgubWF4Tk5vZGVzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlID09IHRoaXMpIHJldHVybiB0cnVlO1xuICBmb3IgKHZhciB2IGluIHRoaXMucGFyZW50cygpKSB7XG4gICAgdmFyIG4gPSB0aGlzLmdyYXBoLm5vZGVzQnlJZFt0aGlzLnBhcmVudHMoKVt2XV07XG4gICAgaWYgKG4gJiYgbi5pc0FuY2VzdG9yKG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5nZXRQYXRoVG9Db21tb25BbmNlc3RvciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgdmFyIHRoaXNOb2RlID0gdGhpcztcbiAgd2hpbGUgKHRoaXNOb2RlICYmICFub2RlLmlzQW5jZXN0b3IodGhpc05vZGUpKSB7XG4gICAgcGF0aC5wdXNoKHRoaXNOb2RlKTtcbiAgICB0aGlzTm9kZSA9IHRoaXMuZ3JhcGgubm9kZXNCeUlkW3RoaXNOb2RlLnBhcmVudHMoKVswXV07XG4gIH1cbiAgaWYgKHRoaXNOb2RlKVxuICAgIHBhdGgucHVzaCh0aGlzTm9kZSk7XG4gIHJldHVybiBwYXRoO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlU2VsZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYmVmb3JlVGhpc0NSID0gdGhpcy5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgYmVmb3JlQmVsb3dDUiA9IG51bGw7XG4gIGlmICh0aGlzLmJlbG93Tm9kZSlcbiAgICBiZWZvcmVCZWxvd0NSID0gdGhpcy5iZWxvd05vZGUuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICB2YXIgcHJldlNlbGVjdGVkICA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCEocHJldlNlbGVjdGVkIGluc3RhbmNlb2YgR2l0Tm9kZVZpZXdNb2RlbCkpIHByZXZTZWxlY3RlZCA9IG51bGw7XG4gIHZhciBwcmV2U2VsZWN0ZWRDUiA9IG51bGw7XG4gIGlmIChwcmV2U2VsZWN0ZWQpIHByZXZTZWxlY3RlZENSID0gcHJldlNlbGVjdGVkLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHRoaXMuc2VsZWN0ZWQoIXRoaXMuc2VsZWN0ZWQoKSk7XG5cbiAgdGhpcy5ncmFwaC5pbnN0YW50VXBkYXRlUG9zaXRpb25zKCk7XG4gIC8vIElmIHdlIGFyZSBkZXNlbGVjdGluZ1xuICBpZiAoIXRoaXMuc2VsZWN0ZWQoKSkge1xuICAgIGlmIChiZWZvcmVUaGlzQ1IudG9wIDwgMCAmJiBiZWZvcmVCZWxvd0NSKSB7XG4gICAgICB2YXIgYWZ0ZXJCZWxvd0NSID0gdGhpcy5iZWxvd05vZGUuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgc2hvd2luZywgdHJ5IHRvIGtlZXAgaXQgaW4gdGhlIHNjcmVlbiAobm8ganVtcGluZylcbiAgICAgIGlmIChiZWZvcmVCZWxvd0NSLnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgYWZ0ZXJCZWxvd0NSLnRvcCAtIGJlZm9yZUJlbG93Q1IudG9wKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHRyeSB0byBicmluZyB0aGVtIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIGFmdGVyQmVsb3dDUi50b3AgLSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICB9XG4gIC8vIElmIHdlIGFyZSBzZWxlY3RpbmdcbiAgfSBlbHNlIHtcbiAgICB2YXIgYWZ0ZXJUaGlzQ1IgPSB0aGlzLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKChwcmV2U2VsZWN0ZWRDUiAmJiAocHJldlNlbGVjdGVkQ1IudG9wIDwgMCB8fCBwcmV2U2VsZWN0ZWRDUi50b3AgPiB3aW5kb3cuaW5uZXJIZWlnaHQpKSAmJlxuICAgICAgYWZ0ZXJUaGlzQ1IudG9wICE9IGJlZm9yZVRoaXNDUi50b3ApIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCAtKGJlZm9yZVRoaXNDUi50b3AgLSBhZnRlclRoaXNDUi50b3ApKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGaXgnKVxuICAgIH1cbiAgfVxufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUubm9kZU1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5vZGVJc01vdXNlaG92ZXIodHJ1ZSk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5ub2RlTW91c2VvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ub2RlSXNNb3VzZWhvdmVyKGZhbHNlKTtcbn1cblxuIiwidmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBTZWxlY3RhYmxlID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdGhpcy5zZWxlY3RlZCA9IGtvLmNvbXB1dGVkKHtcbiAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHRoaXM7XG4gICAgfSxcbiAgICB3cml0ZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAvLyB2YWwgaXMgdGhpcyBpZiB3ZSdyZSBjYWxsZWQgZnJvbSBhIGNsaWNrIGtvIGJpbmRpbmdcbiAgICAgIGlmICh2YWwgPT09IHRoaXMgfHwgdmFsID09PSB0cnVlKSB7XG4gICAgICAgIGdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHRoaXMpIHtcbiAgICAgICAgZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQobnVsbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvd25lcjogdGhpc1xuICB9KTtcbn07XG5leHBvcnRzLlNlbGVjdGFibGUgPSBTZWxlY3RhYmxlO1xuIiwiXG52YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIFZlY3RvcjIgPSByZXF1aXJlKCd1bmdpdC12ZWN0b3IyJyk7XG52YXIgTm9kZVZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vbm9kZScpLk5vZGVWaWV3TW9kZWw7XG52YXIgRWRnZVZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZWRnZScpLkVkZ2VWaWV3TW9kZWw7XG52YXIgQ29sb3IgPSByZXF1aXJlKCdjb2xvcicpO1xuXG5cbmZ1bmN0aW9uIE1lcmdlVmlld01vZGVsKGdyYXBoLCBoZWFkTm9kZSwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuXG4gIHZhciBuZXdOb2RlID0ge1xuICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMihcbiAgICAgIGhlYWROb2RlLngoKSxcbiAgICAgIGhlYWROb2RlLnkoKSAtIDM1KSxcbiAgICByYWRpdXM6IE1hdGgubWF4KGhlYWROb2RlLnJhZGl1cygpLCBub2RlLnJhZGl1cygpKVxuICB9O1xuICBuZXdOb2RlLnBvc2l0aW9uLnkgLT0gbmV3Tm9kZS5yYWRpdXMqMjtcblxuICB0aGlzLm5ld05vZGUgPSBuZXcgTm9kZVZpZXdNb2RlbChuZXdOb2RlLnBvc2l0aW9uLCBuZXdOb2RlLnJhZGl1cyk7XG4gIHRoaXMuZWRnZXMgPSBbXG4gICAgbmV3IEVkZ2VWaWV3TW9kZWwoaGVhZE5vZGUsIHRoaXMubmV3Tm9kZSksXG4gICAgbmV3IEVkZ2VWaWV3TW9kZWwobm9kZSwgdGhpcy5uZXdOb2RlKVxuICBdO1xuICBncmFwaC5kaW1Db21taXQodHJ1ZSlcbn1cbmV4cG9ydHMuTWVyZ2VWaWV3TW9kZWwgPSBNZXJnZVZpZXdNb2RlbDtcbk1lcmdlVmlld01vZGVsLnByb3RvdHlwZS50eXBlID0gJ21lcmdlJztcbk1lcmdlVmlld01vZGVsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ3JhcGguZGltQ29tbWl0KGZhbHNlKVxufVxuXG5cbmZ1bmN0aW9uIFJlYmFzZVZpZXdNb2RlbChvbnRvLCBub2Rlc1RoYXRXaWxsTW92ZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIFxuICB2YXIgcmViYXNlTm9kZXMgPSB7fTtcbiAgdGhpcy5wYXRoID0gbm9kZXNUaGF0V2lsbE1vdmU7XG4gIHRoaXMucGF0aC5zbGljZSgwLCAtMSkuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7IHJlYmFzZU5vZGVzW25vZGUuc2hhMV0gPSB0cnVlOyB9KTtcblxuICB0aGlzLmFycm93cyA9IFtdO1xuICB0aGlzLm5vZGVzID0gdGhpcy5wYXRoLnNsaWNlKDAsIC0xKS5tYXAoZnVuY3Rpb24obm9kZSwgaSkge1xuICAgIGkgPSAoc2VsZi5wYXRoLmxlbmd0aCAtIDEgLSBpKTtcbiAgICB2YXIgbiA9IG5ldyBOb2RlVmlld01vZGVsKFxuICAgICAgbmV3IFZlY3RvcjIoXG4gICAgICAgIG9udG8ueCgpICsgKG5vZGUueCgpIC0gc2VsZi5wYXRoW3NlbGYucGF0aC5sZW5ndGggLSAxXS54KCkpLFxuICAgICAgICBvbnRvLnkoKSAtIGkgKiAobm9kZS5yYWRpdXMoKSAqIDIgKyAyMCkpLFxuICAgICAgbm9kZS5yYWRpdXMoKSk7XG4gICAgdmFyIGQgPSBuLnBvc2l0aW9uKCkuc3ViKG5vZGUucG9zaXRpb24oKSkubm9ybWFsaXplKCk7XG4gICAgdmFyIGZyb20gPSBub2RlLnBvc2l0aW9uKCkuYWRkKGQubXVsKG5vZGUucmFkaXVzKCkgKyAzKSk7XG4gICAgdmFyIHRvID0gbi5wb3NpdGlvbigpLnN1YihkLm11bChub2RlLnJhZGl1cygpKSk7XG4gICAgdmFyIGwgPSB0by5zdWIoZnJvbSkubGVuZ3RoKCk7XG4gICAgaWYgKGwgPiA0NSkgdG8gPSB0by5zdWIoZC5tdWwoNDUpKTtcbiAgICBlbHNlIHRvID0gZnJvbS5hZGQoZCk7XG4gICAgc2VsZi5hcnJvd3MucHVzaCh7IGZyb206IGZyb20sIHRvOiB0byB9KTtcbiAgICByZXR1cm4gbjtcbiAgfSk7XG5cbiAgdGhpcy5lZGdlcyA9IFtdO1xuICB2YXIgcHJldk5vZGUgPSBvbnRvO1xuICB0aGlzLm5vZGVzLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBzZWxmLmVkZ2VzLnB1c2gobmV3IEVkZ2VWaWV3TW9kZWwobm9kZSwgcHJldk5vZGUpKTtcbiAgICBwcmV2Tm9kZSA9IG5vZGU7XG4gIH0pO1xuXG4gIHRoaXMucGF0aC5zbGljZSgwLCAtMSkuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5zYXZlZENvbG9yID0gbm9kZS5jb2xvcigpO1xuICAgIG5vZGUuY29sb3IoQ29sb3Iobm9kZS5jb2xvcigpKS5hbHBoYSgwLjIpLnJnYmFTdHJpbmcoKSk7XG4gIH0pO1xufVxuZXhwb3J0cy5SZWJhc2VWaWV3TW9kZWwgPSBSZWJhc2VWaWV3TW9kZWw7XG5SZWJhc2VWaWV3TW9kZWwucHJvdG90eXBlLnR5cGUgPSAncmViYXNlJztcblJlYmFzZVZpZXdNb2RlbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBhdGguc2xpY2UoMCwgLTEpLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuY29sb3Iobm9kZS5zYXZlZENvbG9yKTtcbiAgfSk7XG59XG5SZWJhc2VWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oZGVsdGFUKSB7XG4gIHRoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS51cGRhdGVBbmltYXRpb25GcmFtZShkZWx0YVQpO1xuICB9KTtcbn1cblxuXG5mdW5jdGlvbiBSZXNldFZpZXdNb2RlbChub2Rlcykge1xuICB0aGlzLm5vZGVzID0gbm9kZXM7XG59XG5leHBvcnRzLlJlc2V0Vmlld01vZGVsID0gUmVzZXRWaWV3TW9kZWw7XG5SZXNldFZpZXdNb2RlbC5wcm90b3R5cGUudHlwZSA9ICdyZXNldCc7XG5cblxuZnVuY3Rpb24gUHVzaFZpZXdNb2RlbChmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gIHRoaXMuZnJvbVBvc2l0aW9uID0gZnJvbU5vZGUucG9zaXRpb24oKS5jbG9uZSgpO1xuICB0aGlzLnRvUG9zaXRpb24gPSB0b05vZGUucG9zaXRpb24oKS5jbG9uZSgpO1xuICB0aGlzLmZyb21Qb3NpdGlvbi54ICs9IGZyb21Ob2RlLnJhZGl1cygpICsgNTA7XG4gIHRoaXMudG9Qb3NpdGlvbi54ICs9IHRvTm9kZS5yYWRpdXMoKSArIDUwO1xuICBpZiAodGhpcy5mcm9tUG9zaXRpb24ueSA+IHRoaXMudG9Qb3NpdGlvbi55KSB7XG4gICAgdGhpcy5mcm9tUG9zaXRpb24ueSAtPSAyMDtcbiAgICB0aGlzLnRvUG9zaXRpb24ueSArPSAyMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZyb21Qb3NpdGlvbi55ICs9IDIwO1xuICAgIHRoaXMudG9Qb3NpdGlvbi55IC09IDIwO1xuICB9XG4gIC8vIGFkanVzdCBmb3IgdGhlIGFycm93XG4gIHZhciBkID0gdGhpcy50b1Bvc2l0aW9uLnN1Yih0aGlzLmZyb21Qb3NpdGlvbikubm9ybWFsaXplKCk7XG4gIHRoaXMudG9Qb3NpdGlvbiA9IHRoaXMudG9Qb3NpdGlvbi5zdWIoZC5tdWwoNDUpKTtcbn1cbmV4cG9ydHMuUHVzaFZpZXdNb2RlbCA9IFB1c2hWaWV3TW9kZWw7XG5QdXNoVmlld01vZGVsLnByb3RvdHlwZS50eXBlID0gJ3B1c2gnOyIsIlxudmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBWZWN0b3IyID0gcmVxdWlyZSgndW5naXQtdmVjdG9yMicpO1xuXG52YXIgRWRnZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKG5vZGVhLCBub2RlYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMubm9kZWEgPSBrby5vYnNlcnZhYmxlKG5vZGVhKTtcbiAgdGhpcy5ub2RlYiA9IGtvLm9ic2VydmFibGUobm9kZWIpO1xuICB0aGlzLngxID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLngyID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLnkxID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLnkyID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLnVwZGF0ZUFuaW1hdGlvbkZyYW1lKCk7XG59XG5leHBvcnRzLkVkZ2VWaWV3TW9kZWwgPSBFZGdlVmlld01vZGVsO1xuRWRnZVZpZXdNb2RlbC5wcm90b3R5cGUuX2dldE5vZGVQb3NpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGZhbGxiYWNrTm9kZSkge1xuICBpZiAobm9kZSAmJiBub2RlLnBvc2l0aW9uKCkpIHtcbiAgICByZXR1cm4gbm9kZS5wb3NpdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGlmIChmYWxsYmFja05vZGUgJiYgZmFsbGJhY2tOb2RlLnBvc2l0aW9uKCkpIHJldHVybiBmYWxsYmFja05vZGUucG9zaXRpb24oKS5hZGQobmV3IFZlY3RvcjIoMCwgMTAwMDApKTtcbiAgICBlbHNlIHJldHVybiBuZXcgVmVjdG9yMigwLCAwKTtcbiAgfVxufVxuRWRnZVZpZXdNb2RlbC5wcm90b3R5cGUuX2dldE5vZGVSYWRpdXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiAobm9kZSA/IG5vZGUub3V0ZXJSYWRpdXMoKSA6IG51bGwpIHx8IDMwO1xufVxuRWRnZVZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihkZWx0YVQpIHtcbiAgdmFyIGEgPSB0aGlzLl9nZXROb2RlUG9zaXRpb24odGhpcy5ub2RlYSgpLCB0aGlzLm5vZGViKCkpO1xuICB2YXIgYiA9IHRoaXMuX2dldE5vZGVQb3NpdGlvbih0aGlzLm5vZGViKCksIHRoaXMubm9kZWEoKSk7XG4gIHZhciBkID0gYi5zdWIoYSk7XG4gIGlmIChkLmxlbmd0aCgpID09IDApIHtcbiAgICB0aGlzLngxKGEueCk7XG4gICAgdGhpcy55MShhLnkpO1xuICAgIHRoaXMueDIoYS54KTtcbiAgICB0aGlzLnkyKGEueSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGQgPSBkLm5vcm1hbGl6ZSgpO1xuICB2YXIgcDEgPSBhLmFkZChkLm11bCh0aGlzLl9nZXROb2RlUmFkaXVzKHRoaXMubm9kZWEoKSkgKyAyKSk7XG4gIHZhciBwMiA9IGIuc3ViKGQubXVsKHRoaXMuX2dldE5vZGVSYWRpdXModGhpcy5ub2RlYigpKSArIDIpKTtcbiAgdGhpcy54MShwMS54KTtcbiAgdGhpcy55MShwMS55KTtcbiAgdGhpcy54MihwMi54KTtcbiAgdGhpcy55MihwMi55KTtcbn0iLCJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgVmVjdG9yMiA9IHJlcXVpcmUoJ3VuZ2l0LXZlY3RvcjInKTtcbnZhciBFZGdlVmlld01vZGVsID0gcmVxdWlyZSgnLi9lZGdlJykuRWRnZVZpZXdNb2RlbDtcblxudmFyIEdyYXBoVmlld01vZGVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5ub2RlcyA9IGtvLm9ic2VydmFibGUoW10pO1xuICB0aGlzLmNvbW1pdE5vZGUgPSBuZXcgQ29tbWl0Tm9kZVZpZXdNb2RlbCh0aGlzKTtcbiAgdGhpcy5jb21taXROb2RlRWRnZSA9IG5ldyBFZGdlVmlld01vZGVsKHRoaXMuY29tbWl0Tm9kZSk7XG4gIHRoaXMub2Zmc2V0ID0ga28ub2JzZXJ2YWJsZShuZXcgVmVjdG9yMigwLCAwKSk7XG4gIHRoaXMuZWRnZXMgPSBrby5vYnNlcnZhYmxlKFtdKTtcbiAgdGhpcy5zaG93Q29tbWl0Tm9kZSA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5kaW1Db21taXQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5jb21taXRPcGFjaXR5ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLmRpbUNvbW1pdCgpID8gMC4xIDogMTsgfSk7XG4gIHRoaXMuZ3JhcGhXaWR0aCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgc2VsZi5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbm9kZS54KCkgKyBub2RlLnJhZGl1cygpICsgc2VsZi5vZmZzZXQoKS54ICsgMjAwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gd2lkdGg7XG4gIH0pO1xuICB0aGlzLmdyYXBoSGVpZ2h0ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgc2VsZi5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBub2RlLnkoKSArIG5vZGUucmFkaXVzKCkgKyBzZWxmLm9mZnNldCgpLnkgKyA1KTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9KTtcblxuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljID0ga28ub2JzZXJ2YWJsZSgpO1xuICB2YXIgcHJldkhvdmVyR3JhcGhpYztcbiAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYy5zdWJzY3JpYmUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICBwcmV2SG92ZXJHcmFwaGljID0gdmFsdWU7XG4gIH0sIG51bGwsICdiZWZvcmVDaGFuZ2UnKTtcbiAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYy5zdWJzY3JpYmUoZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICBpZiAobmV3VmFsdWUgIT0gcHJldkhvdmVyR3JhcGhpYyAmJiBwcmV2SG92ZXJHcmFwaGljICYmIHByZXZIb3ZlckdyYXBoaWMuZGVzdHJveSlcbiAgICAgIHByZXZIb3ZlckdyYXBoaWMuZGVzdHJveSgpO1xuICB9KTtcbiAgdGhpcy5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpY1R5cGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYygpID8gc2VsZi5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYygpLnR5cGUgOiAnJztcbiAgfSlcbn1cbmV4cG9ydHMuR3JhcGhWaWV3TW9kZWwgPSBHcmFwaFZpZXdNb2RlbDtcbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGRlbHRhVCkge1xuICBpZiAodGhpcy5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYygpICYmIHRoaXMuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMoKS51cGRhdGVBbmltYXRpb25GcmFtZSkge1xuICAgIHRoaXMuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMoKS51cGRhdGVBbmltYXRpb25GcmFtZShkZWx0YVQpO1xuICB9XG4gIHRoaXMubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLnVwZGF0ZUFuaW1hdGlvbkZyYW1lKGRlbHRhVCk7XG4gIH0pO1xuICB0aGlzLmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbihlZGdlKSB7XG4gICAgZWRnZS51cGRhdGVBbmltYXRpb25GcmFtZShkZWx0YVQpO1xuICB9KTtcbiAgdGhpcy5jb21taXROb2RlRWRnZS51cGRhdGVBbmltYXRpb25GcmFtZShkZWx0YVQpO1xufVxuXG52YXIgQ29tbWl0Tm9kZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHRoaXMucG9zaXRpb24gPSBrby5vYnNlcnZhYmxlKG5ldyBWZWN0b3IyKDMwLCAzMCkpO1xuICB0aGlzLnJhZGl1cyA9IGtvLm9ic2VydmFibGUoMjgpO1xuICB0aGlzLm91dGVyUmFkaXVzID0ga28ub2JzZXJ2YWJsZSgzMik7XG4gIC8vdGhpcy5jb2xvciA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkgeyByZXR1cm4gZ3JhcGguSEVBRCgpICYmIGdyYXBoLkhFQUQoKS5pZGVvbG9naWNhbEJyYW5jaCgpID8gZ3JhcGguSEVBRCgpLmlkZW9sb2dpY2FsQnJhbmNoKCkuY29sb3IgOiAnIzY2NicgfSk7XG4gIHRoaXMuY29sb3IgPSBrby5vYnNlcnZhYmxlKCcjZmYwMGZmJylcbn0iLCJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgVmVjdG9yMiA9IHJlcXVpcmUoJ3VuZ2l0LXZlY3RvcjInKTtcblxudmFyIE5vZGVWaWV3TW9kZWwgPSBmdW5jdGlvbihwb3NpdGlvbiwgcmFkaXVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5wb3NpdGlvbiA9IGtvLm9ic2VydmFibGUocG9zaXRpb24pO1xuICB0aGlzLmdvYWxQb3NpdGlvbiA9IGtvLm9ic2VydmFibGUocG9zaXRpb24pO1xuICB0aGlzLmlzQXRGaW5hbFhQb3NpdGlvbiA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5nb2FsUG9zaXRpb24oKSB8fCAhc2VsZi5wb3NpdGlvbigpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5wb3NpdGlvbigpLnggPT0gc2VsZi5nb2FsUG9zaXRpb24oKS54O1xuICB9KTtcbiAgdGhpcy54ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLnBvc2l0aW9uKCkgPyBzZWxmLnBvc2l0aW9uKCkueCA6IDA7IH0pO1xuICB0aGlzLnkgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYucG9zaXRpb24oKSA/IHNlbGYucG9zaXRpb24oKS55IDogMDsgfSk7XG4gIHRoaXMucmFkaXVzID0ga28ub2JzZXJ2YWJsZShyYWRpdXMgfHwgMzApO1xuICB0aGlzLm91dGVyUmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gIHRoaXMuZ29hbFJhZGl1cyA9IGtvLm9ic2VydmFibGUocmFkaXVzKTtcbiAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDAuNDtcbiAgdGhpcy5jb2xvciA9IGtvLm9ic2VydmFibGUoJyNmZjAwZmYnKTtcbiAgdGhpcy5zZWxlY3RlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xufVxuZXhwb3J0cy5Ob2RlVmlld01vZGVsID0gTm9kZVZpZXdNb2RlbDtcbk5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnByZXZQb3NpdGlvbiA9IHNlbGYucG9zaXRpb24oKTtcbiAgaWYgKCFzZWxmLmdvYWxQb3NpdGlvbigpKSBzZWxmLnBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgc2VsZi5nb2FsUG9zaXRpb24ocG9zaXRpb24pO1xufVxuTm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuc2V0UmFkaXVzID0gZnVuY3Rpb24ocmFkaXVzKSB7XG4gIHRoaXMucHJldlJhZGl1cyA9IHRoaXMucmFkaXVzKCk7XG4gIGlmICghdGhpcy5nb2FsUmFkaXVzKCkpIHRoaXMucmFkaXVzKHJhZGl1cyk7XG4gIHRoaXMuZ29hbFJhZGl1cyhyYWRpdXMpO1xuICB0aGlzLnNldFJhZGl1c1RpbWVzdGFtcCA9IERhdGUubm93KCk7XG59XG5Ob2RlVmlld01vZGVsLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGRlbHRhVCkge1xuICB2YXIgdG90YWxUaW1lID0gNTAwO1xuXG4gIHZhciBkID0gdGhpcy5nb2FsUG9zaXRpb24oKS5zdWIodGhpcy5wb3NpdGlvbigpIHx8IG5ldyBWZWN0b3IyKDAsIDApKTtcbiAgdmFyIGRpc3RhbmNlTGVmdCA9IGQubGVuZ3RoKCk7XG4gIGlmIChkaXN0YW5jZUxlZnQgIT0gMCkge1xuXG4gICAgZCA9IHRoaXMuZ29hbFBvc2l0aW9uKCkuc3ViKHRoaXMucHJldlBvc2l0aW9uIHx8IG5ldyBWZWN0b3IyKDAsIDApKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGQubGVuZ3RoKCk7XG4gICAgdmFyIGxlbmd0aFRvTW92ZSA9IGRlbHRhVCAqIHRoaXMuYW5pbWF0aW9uU3BlZWQ7XG4gICAgaWYgKGRpc3RhbmNlTGVmdCA8IGxlbmd0aFRvTW92ZSkge1xuICAgICAgdGhpcy5wb3NpdGlvbih0aGlzLmdvYWxQb3NpdGlvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IGQubm9ybWFsaXplKCkubXVsKGxlbmd0aFRvTW92ZSk7XG5cbiAgICAgIHZhciBwb3MgPSAodGhpcy5wb3NpdGlvbigpIHx8IG5ldyBWZWN0b3IyKDAsIDApKS5hZGQoZCk7XG4gICAgICB0aGlzLnBvc2l0aW9uKHBvcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJhZGl1c0xlZnQgPSB0aGlzLmdvYWxSYWRpdXMoKSAtIHRoaXMucmFkaXVzKCk7XG4gIGlmIChyYWRpdXNMZWZ0ICE9IDApIHtcbiAgICB2YXIgc2lnbiA9IHJhZGl1c0xlZnQgPyByYWRpdXNMZWZ0IDwgMCA/IC0xIDogMSA6IDA7XG4gICAgcmFkaXVzTGVmdCA9IE1hdGguYWJzKHJhZGl1c0xlZnQpO1xuICAgIHZhciB0b3RhbFJhZGl1c0RpZmYgPSBNYXRoLmFicyh0aGlzLmdvYWxSYWRpdXMoKSAtIHRoaXMucHJldlJhZGl1cyk7XG4gICAgdmFyIHJhZGl1c1RvQ2hhbmdlID0gdG90YWxSYWRpdXNEaWZmICogZGVsdGFUIC8gdG90YWxUaW1lO1xuICAgIGlmIChyYWRpdXNMZWZ0IDwgcmFkaXVzVG9DaGFuZ2UpIHtcbiAgICAgIHRoaXMucmFkaXVzKHRoaXMuZ29hbFJhZGl1cygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYWRpdXModGhpcy5yYWRpdXMoKSArIHNpZ24gKiByYWRpdXNUb0NoYW5nZSk7XG4gICAgfVxuICB9XG59XG4iLCJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgbWQ1ID0gcmVxdWlyZSgnYmx1ZWltcC1tZDUnKS5tZDU7XG52YXIgU2VsZWN0YWJsZSA9IHJlcXVpcmUoJy4vZ2l0LXNlbGVjdGFibGUnKS5TZWxlY3RhYmxlO1xudmFyIHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG5cbnZhciBSZWZWaWV3TW9kZWwgPSBmdW5jdGlvbihhcmdzKSB7XG4gIFNlbGVjdGFibGUuY2FsbCh0aGlzLCBhcmdzLmdyYXBoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLm5vZGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuYm94RGlzcGxheVggPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYubm9kZSgpKSByZXR1cm4gMDtcbiAgICByZXR1cm4gc2VsZi5ub2RlKCkueCgpO1xuICB9KTtcbiAgdGhpcy5ib3hEaXNwbGF5WSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5ub2RlKCkpIHJldHVybiAwO1xuICAgIHJldHVybiBzZWxmLm5vZGUoKS55KCk7XG4gIH0pO1xuICB0aGlzLm5hbWUgPSBhcmdzLm5hbWU7XG4gIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lOyAvLyBvcmlnaW4vbWFzdGVyIG9yIG1hc3RlclxuICB0aGlzLnJlZk5hbWUgPSB0aGlzLm5hbWU7IC8vIG1hc3RlclxuICB0aGlzLmlzUmVtb3RlVGFnID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlbW90ZS10YWc6ICcpID09IDA7XG4gIHRoaXMuaXNMb2NhbFRhZyA9IHRoaXMubmFtZS5pbmRleE9mKCd0YWc6ICcpID09IDA7XG4gIHRoaXMuaXNUYWcgPSB0aGlzLmlzTG9jYWxUYWcgfHwgdGhpcy5pc1JlbW90ZVRhZztcbiAgdmFyIGlzUmVtb3RlQnJhbmNoT3JIRUFEID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlZnMvcmVtb3Rlcy8nKSA9PSAwO1xuICB0aGlzLmlzTG9jYWxIRUFEID0gdGhpcy5uYW1lID09ICdIRUFEJztcbiAgdGhpcy5pc1JlbW90ZUhFQUQgPSB0aGlzLm5hbWUuaW5kZXhPZignL0hFQUQnKSAhPSAtMTtcbiAgdGhpcy5pc0xvY2FsQnJhbmNoID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlZnMvaGVhZHMvJykgPT0gMDtcbiAgdGhpcy5pc1JlbW90ZUJyYW5jaCA9IGlzUmVtb3RlQnJhbmNoT3JIRUFEICYmICF0aGlzLmlzUmVtb3RlSEVBRDtcbiAgdGhpcy5pc1N0YXNoID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlZnMvc3Rhc2gnKSA9PSAwO1xuICB0aGlzLmlzSEVBRCA9IHRoaXMuaXNMb2NhbEhFQUQgfHwgdGhpcy5pc1JlbW90ZUhFQUQ7XG4gIHRoaXMuaXNCcmFuY2ggPSB0aGlzLmlzTG9jYWxCcmFuY2ggfHwgdGhpcy5pc1JlbW90ZUJyYW5jaDtcbiAgdGhpcy5pc1JlbW90ZSA9IGlzUmVtb3RlQnJhbmNoT3JIRUFEIHx8IHRoaXMuaXNSZW1vdGVUYWc7XG4gIHRoaXMuaXNMb2NhbCA9IHRoaXMuaXNMb2NhbEJyYW5jaCB8fCB0aGlzLmlzTG9jYWxUYWc7XG4gIGlmICh0aGlzLmlzTG9jYWxCcmFuY2gpIHtcbiAgICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZS5zbGljZSgncmVmcy9oZWFkcy8nLmxlbmd0aCk7XG4gICAgdGhpcy5yZWZOYW1lID0gdGhpcy5sb2NhbFJlZk5hbWU7XG4gIH1cbiAgaWYgKHRoaXMuaXNSZW1vdGVCcmFuY2gpIHtcbiAgICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZS5zbGljZSgncmVmcy9yZW1vdGVzLycubGVuZ3RoKTtcbiAgfVxuICBpZiAodGhpcy5pc0xvY2FsVGFnKSB7XG4gICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3RhZzogcmVmcy90YWdzLycubGVuZ3RoKTtcbiAgICB0aGlzLnJlZk5hbWUgPSB0aGlzLmxvY2FsUmVmTmFtZTtcbiAgfVxuICBpZiAodGhpcy5pc1JlbW90ZVRhZykge1xuICAgIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lLnNsaWNlKCdyZW1vdGUtdGFnOiAnLmxlbmd0aCk7XG4gIH1cbiAgaWYgKHRoaXMuaXNSZW1vdGUpIHtcbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBvcmlnaW4vIHBhcnQgb2Ygb3JpZ2luL2JyYW5jaG5hbWVcbiAgICB2YXIgcyA9IHRoaXMubG9jYWxSZWZOYW1lLnNwbGl0KCcvJyk7XG4gICAgdGhpcy5yZW1vdGUgPSBzWzBdO1xuICAgIHRoaXMucmVmTmFtZSA9IHMuc2xpY2UoMSkuam9pbignLycpO1xuICB9XG4gIHRoaXMuc2hvdyA9IHRydWU7XG4gIHRoaXMuZ3JhcGggPSBhcmdzLmdyYXBoO1xuICB0aGlzLnNlcnZlciA9IHRoaXMuZ3JhcGguc2VydmVyO1xuICB0aGlzLmxvY2FsUmVmID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmlzRHJhZ2dpbmcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5jdXJyZW50ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuaXNMb2NhbEJyYW5jaCAmJiBzZWxmLmdyYXBoLmNoZWNrZWRPdXRCcmFuY2goKSA9PSBzZWxmLnJlZk5hbWU7XG4gIH0pO1xuICB0aGlzLmNvbG9yID0gYXJncy5jb2xvciB8fCB0aGlzLl9jb2xvckZyb21IYXNoT2ZTdHJpbmcodGhpcy5uYW1lKTtcbn1cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuX2NvbG9yRnJvbUhhc2hPZlN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICByZXR1cm4gJyMnICsgbWQ1KHN0cmluZykudG9TdHJpbmcoKS5zbGljZSgwLCA2KTtcbn1cbmV4cG9ydHMuUmVmVmlld01vZGVsID0gUmVmVmlld01vZGVsO1xuUmVmVmlld01vZGVsLnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCh0aGlzKTtcbiAgdGhpcy5pc0RyYWdnaW5nKHRydWUpO1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dChudWxsKTtcbiAgdGhpcy5pc0RyYWdnaW5nKGZhbHNlKTtcbn1cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuY2FuQmVQdXNoZWQgPSBmdW5jdGlvbihyZW1vdGUpIHtcbiAgaWYgKCF0aGlzLmlzTG9jYWwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHJlbW90ZVJlZiA9IHRoaXMuZ2V0UmVtb3RlUmVmKHJlbW90ZSk7XG4gIGlmICghcmVtb3RlUmVmKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHRoaXMubm9kZSgpICE9IHJlbW90ZVJlZi5ub2RlKCk7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmdldFJlbW90ZVJlZiA9IGZ1bmN0aW9uKHJlbW90ZSkge1xuICByZXR1cm4gdGhpcy5ncmFwaC5nZXRSZWYodGhpcy5nZXRSZW1vdGVSZWZGdWxsTmFtZShyZW1vdGUpLCBmYWxzZSk7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmdldFJlbW90ZVJlZkZ1bGxOYW1lID0gZnVuY3Rpb24ocmVtb3RlKSB7XG4gIGlmICh0aGlzLmlzTG9jYWxCcmFuY2gpIHJldHVybiAncmVmcy9yZW1vdGVzLycgKyByZW1vdGUgKyAnLycgKyB0aGlzLnJlZk5hbWU7XG4gIGlmICh0aGlzLmlzTG9jYWxUYWcpIHJldHVybiAncmVtb3RlLXRhZzogJyArIHJlbW90ZSArICcvJyArIHRoaXMucmVmTmFtZTtcbiAgcmV0dXJuIG51bGw7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVybCA9IHRoaXMuaXNUYWcgPyAnL3RhZ3MnIDogJy9icmFuY2hlcyc7XG4gIGlmICh0aGlzLmlzUmVtb3RlKSB1cmwgPSAnL3JlbW90ZScgKyB1cmw7XG4gIHRoaXMuc2VydmVyLmRlbCh1cmwsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgcmVtb3RlOiB0aGlzLmlzUmVtb3RlID8gdGhpcy5yZW1vdGUgOiBudWxsLCBuYW1lOiB0aGlzLnJlZk5hbWUgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICBzZWxmLmdyYXBoLmxvYWROb2Rlc0Zyb21BcGkoKTtcbiAgICBpZiAodXJsID09ICcvcmVtb3RlL3RhZ3MnKSB7XG4gICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LWZldGNoLXRhZ3MnIH0pO1xuICAgIH1cbiAgfSk7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5pc0xvY2FsKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCgpKVxuICAgICAgdGhpcy5zZXJ2ZXIucG9zdCgnL3Jlc2V0JywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLCB0bzogdGFyZ2V0LCBtb2RlOiAnaGFyZCcgfSwgY2FsbGJhY2spO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNUYWcpXG4gICAgICB0aGlzLnNlcnZlci5wb3N0KCcvdGFncycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCwgbmFtZTogdGhpcy5yZWZOYW1lLCBzdGFydFBvaW50OiB0YXJnZXQsIGZvcmNlOiB0cnVlIH0sIGNhbGxiYWNrKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnNlcnZlci5wb3N0KCcvYnJhbmNoZXMnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIG5hbWU6IHRoaXMucmVmTmFtZSwgc3RhcnRQb2ludDogdGFyZ2V0LCBmb3JjZTogdHJ1ZSB9LCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHB1c2hSZXEgPSB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIHJlbW90ZTogdGhpcy5yZW1vdGUsXG4gICAgICByZWZTcGVjOiB0YXJnZXQsIHJlbW90ZUJyYW5jaDogdGhpcy5yZWZOYW1lIH07XG4gICAgdGhpcy5zZXJ2ZXIucG9zdCgnL3B1c2gnLCBwdXNoUmVxLCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgPT0gJ25vbi1mYXN0LWZvcndhcmQnKSB7XG4gICAgICAgICAgICB2YXIgZm9yY2VQdXNoRGlhbG9nID0gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0ZvcmNlIHB1c2g/JywgZGV0YWlsczogJ1RoZSByZW1vdGUgYnJhbmNoIGNhblxcJ3QgYmUgZmFzdC1mb3J3YXJkZWQuJyB9KTtcbiAgICAgICAgICAgIGZvcmNlUHVzaERpYWxvZy5jbG9zZWQuYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoIWZvcmNlUHVzaERpYWxvZy5yZXN1bHQoKSkgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHB1c2hSZXEuZm9yY2UgPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxmLnNlcnZlci5wb3N0KCcvcHVzaCcsIHB1c2hSZXEsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1zaG93LWRpYWxvZycsIGRpYWxvZzogZm9yY2VQdXNoRGlhbG9nIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbn1cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlUmVmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL3B1c2gnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgsIHJlbW90ZTogdGhpcy5ncmFwaC5jdXJyZW50UmVtb3RlKCksXG4gICAgICByZWZTcGVjOiB0aGlzLnJlZk5hbWUsIHJlbW90ZUJyYW5jaDogdGhpcy5yZWZOYW1lIH0sIGNhbGxiYWNrKTtcbn0iXX0=
